using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Xml.Serialization;

namespace ManualMapper
{
    public class TypePair
    {
        public Type Source { get; set; }
        public Type Target { get; set; }
    }
    
    public class MappingMethod
    {
        public TypePair Types { get; set; }
        public string Body { get; set; }
        public string Name { get; set; }
    }

    class Program
    {
        // example ""D:\src\BOQESB\Channel\FinnOne\Notifications\main\Adapters\bin\Debug\BOQESB.Channel.FinnOne.Notifications.Adapters.dll" "BOQESB.Channel.FinnOne.Notifications.Adapters.ApplicationService.RetrieveApplicationResponse" "D:\src\BOQESB\Channel\FinnOne\Notifications\main\packages\BOQESB.Lending.Notifications.Events.1.1.5.0\lib\net40\BOQESB.Lending.Notifications.Events.dll" "BOQESB.Lending.Notifications.Events.Generated.ApplicationType" "Foobar"

        private static Dictionary<TypePair, MappingMethod> methodDictionary = new Dictionary<TypePair, MappingMethod>();

        static void Main(string[] args)
        {
            var sourceAsmName = args[0];
            var sourceTypeName = args[1];

            var targetAsmName = args[2];
            var targetTypeName = args[3];

            var targetNs = args[4];

            var sourcAsm = Assembly.LoadFrom(sourceAsmName);
            var sourceType = sourcAsm.GetType(sourceTypeName);

            var targetAsm = Assembly.LoadFrom(targetAsmName);
            var targetType = targetAsm.GetType(targetTypeName);

            GenerateTypeMappingCode(sourceType, targetType);

            Console.WriteLine("using System;");
            Console.WriteLine("using System.Collections.Generic;");
            Console.WriteLine("// this code was generated by a tool at " + DateTime.Now.ToShortDateString() + " " + DateTime.Now.ToLongTimeString());
            Console.WriteLine("");

            Console.WriteLine("namespace " + targetNs);
            Console.WriteLine("{");

            Console.WriteLine("\tpublic partial class Mapping {");

            foreach (var method in methodDictionary)
            {
                Console.Write(method.Value.Body);
                Console.WriteLine("");
            }

            Console.WriteLine("\t}");

            Console.WriteLine("}");
        }

        private static string GenerateTypeMappingCode(Type sourceType, Type targetType)
        {
            var existing = methodDictionary.Keys.FirstOrDefault(a => a.Source == sourceType && a.Target == targetType);
            if (existing != null)
            {
                return methodDictionary[existing].Name;
            }

            System.Diagnostics.Debug.WriteLine("Mapping " + sourceType.Name + " to " + targetType.Name);

            var sb = new StringBuilder();

            var methodName = GenerateMethodName(sourceType, targetType);

            var tp = new TypePair() { Source = sourceType, Target = targetType };
            methodDictionary.Add(tp, new MappingMethod() { Types = tp, Body = "// TODO", Name = methodName });

            var indentation = "\t\t";

            sb.AppendFormat(indentation + "public virtual {2} {0}({1} source)\n", methodName, sourceType.FullName, targetType.FullName);
            sb.AppendLine(indentation + "{");

            indentation += "\t";

            if (sourceType.IsArray && targetType.IsArray)
            {
                var srcArrType = sourceType.GetElementType();
                var tgtArrType = targetType.GetElementType();

                var instanceMappingName = GenerateTypeMappingCode(srcArrType, tgtArrType);
                sb.AppendLine(indentation + "if (source == null){ return null; }\n");
                sb.AppendFormat(indentation + "var items = new List<{0}>();\n", tgtArrType);
                sb.AppendFormat(indentation + "foreach (var item in source)\n");
                sb.AppendLine(indentation + "{");
                sb.AppendFormat(indentation + "\tvar mappedItem = {0}(item);\n", instanceMappingName);
                sb.AppendLine(indentation + "\titems.Add(mappedItem);");
                sb.AppendLine(indentation + "}");
                sb.AppendLine(indentation + "return items.ToArray();");
            }
            else if (sourceType.IsEnum && targetType.IsEnum)
            {
                sb.AppendFormat(indentation + "return ({0})Enum.Parse(typeof({0}), source.ToString());\n", targetType.FullName);
            }
            else
            {
                if (targetType.IsValueType && !sourceType.IsValueType)
                {
                    sb.AppendLine(indentation + "throw new NotImplementedException();"); 
                }
                else
                {
                    sb.AppendLine(indentation + "if (source == null){ return null; }\n");
                    sb.AppendFormat(indentation + "var target = new {0}();\n", targetType);
                    MapFields(sourceType, targetType, sb, indentation);
                    sb.AppendLine(indentation + "return target;");                    
                }
            }


            sb.AppendLine("\t\t}");

            methodDictionary[tp].Body = sb.ToString();

            return methodName;
        }

        private static void MapFields(Type sourceType, Type targetType, StringBuilder sb, string indentation)
        {

            var sourceFields = GetProperties(sourceType);
            var targetFields = GetProperties(targetType);

            List<PropertyInfo> mappedFields = new List<PropertyInfo>();

            foreach (var target in targetFields)
            {
                
                var source = GetMatchingProperty(target, sourceFields, mappedFields);
                if (source == null)
                {
                    sb.AppendLine(indentation + "// cannot map target " + target.Name);
                }
                else
                {
                    GenerateFieldMapping(target, source, sb, indentation);
                }
            }
        }

        private static void GenerateFieldMapping(PropertyInfo target, PropertyInfo source, StringBuilder sb, string indentation)
        {
            XmlElementAttribute[] attribs = (XmlElementAttribute[]) Attribute.GetCustomAttributes(target, typeof(XmlElementAttribute));
            if (attribs != null && attribs.Length > 1)
            {
                // this is a 'choice';
                XmlElementAttribute[] srcAttributes = (XmlElementAttribute[])Attribute.GetCustomAttributes(source, typeof(XmlElementAttribute));
                foreach (var tgtAttrib in attribs)
                {
                    var matchingSrc = srcAttributes.FirstOrDefault(a => a.ElementName == tgtAttrib.ElementName || tgtAttrib.ElementName.EndsWith(a.ElementName) || a.ElementName.EndsWith(tgtAttrib.ElementName));
                    if (matchingSrc != null)
                    {
                        sb.AppendFormat(indentation + "if (source.{0} is {1})\n", source.Name, matchingSrc.Type.FullName);
                        sb.AppendLine(indentation + "{");
                        var localVariableName = tgtAttrib.ElementName;
                        sb.AppendFormat(indentation + "\tvar {0} = source.{1} as {2};\n", localVariableName, source.Name, matchingSrc.Type);

                        if (tgtAttrib.Type.IsAssignableFrom(matchingSrc.Type))
                        {
                            sb.AppendFormat(indentation + "\ttarget.{0} = {1};\n", target.Name, localVariableName);
                        }
                        else
                        {
                            var methodName = GenerateTypeMappingCode(matchingSrc.Type, tgtAttrib.Type);
                            sb.AppendFormat(indentation + "\ttarget.{0} = {1}({2});\n", target.Name, methodName, localVariableName);
                        }

                        sb.AppendLine(indentation + "}\n");
                    }
                    else
                    {
                        sb.AppendFormat(indentation + "// {0} doesn't seem similar to any of the other types be mapped to \n", tgtAttrib.ElementName);
                    }
                }
                return;
            }

            if (CanBeDirectlyAssigned(source, target))
            {
                sb.AppendFormat(indentation + "target.{0} = source.{1};\n", target.Name, source.Name);
            }
            else
            {
                var methodName = GenerateTypeMappingCode(source.PropertyType, target.PropertyType);
                sb.AppendFormat(indentation + "target.{0} = {1}(source.{2});\n", target.Name, methodName, source.Name);
            }
        }

        private static bool CanBeDirectlyAssigned(PropertyInfo source, PropertyInfo target)
        {
            return target.PropertyType.IsAssignableFrom(source.PropertyType);
        }

        private static PropertyInfo GetMatchingProperty(PropertyInfo target, PropertyInfo[] sourceFields, List<PropertyInfo> mappedFields)
        {
            var source = sourceFields.FirstOrDefault(a => a.Name == target.Name); // TODO - make much more sophisticated
            return source;
        }

        private static PropertyInfo[] GetProperties(Type type)
        {
            return type.GetProperties(BindingFlags.Public | BindingFlags.Instance);
        }

        private static string GenerateMethodName(Type sourceType, Type targetType)
        {
            if (sourceType.IsArray && targetType.IsArray)
            {
                return sourceType.GetElementType().Name + "ArrayTo" + targetType.GetElementType().Name + "Array";
            }
            else
            {
                return sourceType.Name + "To" + targetType.Name;                
            }
        }
    }
}
