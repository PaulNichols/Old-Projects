<?xml version="1.0" encoding="utf-8" ?> 
<build xmlns="urn:Microsoft:Sdc:Configuration:Build:1.2" 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xsi:schemaLocation="urn:Microsoft:Sdc:Configuration:Build:1.2 Microsoft.Sdc.Configuration.Build.1.2.xsd">

  <!-- ==========================================  -->
  <!-- INFORMATION
        This file needs to in the build location on the build server:
            Build Server: Map to c$ on 'FPCS Build Server (d826055)'
            File Location: \BuildTools\UPD\UPDBuildScript.xml
            Accompanying files: Replacements.txt (same location as UPDBuildScript.xml)
  -->

  <!-- ==========================================  -->
  <!-- GLOBAL SETTINGS                             
  This first section contains some variables that are used further down the script.  
  It is a place where the overall behaviour of the script
  can be altered using friendly name/value pairs without having to dig through the script.
  -->
  <message section="PreBuild" action="console" text="SECTION(00) - Starting." newLine="true"/>
  <message section="PreBuild" action="console" text="SECTION(05) - Establish global settings." newLine="true"/>
  <set name="ConfigurationToBuild" value="Release"/>
  <set name="SolutionFilename" value="SLN_UPD.sln"/>
  <set name="ProjectTitle" value="UPD"/>
  <set name="MajorVersionNo" value="2"/>
  <set name="MinorVersionNo" value="5"/>
  <set name="ScriptVersionName" value="DailyBuild"/>
  <set name="ProjectStatusVirtualDirectory" value="http://D826055/BuildResults/UPD_Status" />  
  <set name="ProjectStatusPhysicalDirectory" value="C:\BuildResults\UPD_Status" />
  <set name="VersioningFragmentFilename" value="VersioningFragment.xml"/>
  <set name="InstallerProjectFilename" value="Installer.vdproj"/>
  <set name="VaultURLOfVersioningFragment" value="$(VaultSolutionPath)$(VersioningFragmentFilename)"/>
  <set name="VaultURLOfInstallerProject" value="$(VaultSolutionPath)Installer/$(InstallerProjectFilename)"/>
 
  <!-- ==========================================  -->
  
  <message section="PreBuild" action="console" text="SECTION(10) - Pre Build - Preparing Workstation for the build." newLine="true"/>
  <!-- ========================================== -->
  <!-- SECTION(10) Pre Build - Preparing Workstation for the build. 
  This section does the initial preparation - it will delete all previous script attempts, 
  create the directory structure that is to be used for the script and set up things like 
  the log location and the location that the source code is to be fetched to
  -->
  <!-- ==========================================  -->
  
  <message section="PreBuild" action="console" text=" 10.1		» Pre Build Stage Begins." newLine="true"/>
  <!--Firstly create ourselves a working folder -->
  <message section="PreBuild" action="console" text=" 10.2		» Creating Working Folder in $(DevsPreferredPath)\$(ProjectTitle)" newLine="true"/>
  <!-- NB 
  devs preferred path replacement is stored in the replacements.txt file and this 
  should be updated for your box so that devspreferred path is correctly populated 
  with your preferred directory for the build to perform its operations in-->
  <folder section="PreBuild" action="create" force="true" path="$(DevsPreferredPath)\$(ProjectTitle)" stopOnError="false"/>
  <folder section="PreBuild" action="delete" force="true" path="$(DevsPreferredPath)\$(ProjectTitle)\Working" stopOnError="false"/>
  <folder section="PreBuild" action="create" force="true" path="$(DevsPreferredPath)\$(ProjectTitle)\Working" stopOnError="true"/>
  <!-- Now prepare a location for the Log file to be stored -->
  <message section="PreBuild" action="console" text=" 10.3		» Creating Logfile in working\output" newLine="true"/>
  <folder section="PreBuild" action="delete" force="true" path="$(DevsPreferredPath)\$(ProjectTitle)\Working\Output" stopOnError="false"/>
  <folder section="PreBuild" action="create" path="$(DevsPreferredPath)\$(ProjectTitle)\Working\Output" stopOnError="true"/>
  
  <!-- No matter if we're cleaning the build or not we should establish a log for build output -->
  <logOutput section="PreBuild" path="$(DevsPreferredPath)\$(ProjectTitle)\Working\Output\build.log" verbose="Detailed" stopOnError="true"/>
  
  <!-- Remove any old NDOC documentation -->
  <message section="PreBuild" action="console" text=" 10.4		» Establishing NDOC output folder in $(ProjectStatusPhysicalDirectory)\NDOC" newLine="true"/>
  <folder section="PreBuild" action="delete" force="true" path="$(ProjectStatusPhysicalDirectory)\NDOC" stopOnError="false"/>
  <folder section="PreBuild" action="delete" force="true" path="$(NDOCOutput)" stopOnError="false"/>
  <folder section="PreBuild" action="create" path="$(ProjectStatusPhysicalDirectory)\NDOC" stopOnError="true"/>

  <!-- This build script maps a drive to the preferred location so that paths are 
  simple - there is no reason or requirement to do this its just one way of working.  
  Build scripts can choose to follow this or not, the only known issue with using 
  mapped drives is that IIS virtuals have problems when being mapped to paths on mapped drives -->
  
  <!-- Now map this location to the S: drive substitution -->
  <message section="PreBuild" action="console" text=" 10.5		» Preparing S: Drive" newLine="true"/>
  
  <!-- Delete the S: Substitution in prep for a new one -->
  <run section="PreBuild" path="%WINDIR%\system32\subst.exe" 
    parameters="$(DriveToMapForSource) /D" stopOnError="false" waitForExit="true"/>
  
  <!--resubstitute the s drive -->
  <run section="PreBuild" path="%WINDIR%\system32\subst.exe" 
    parameters="$(DriveToMapForSource) $(DevsPreferredPath)\$(ProjectTitle)\Working" 
    stopOnError="true" workingDirectory="$(CurrentFolder)" waitForExit="true"/>
    
  <!-- The delete of the working directory will have purged these also therefore 
  dont need to delete before them -->
  <folder section="PreBuild" action="create" force="true" path="$(DriveToMapForSource)\Source" stopOnError="true"/>
  <folder section="PreBuild" action="create" force="true" path="$(DriveToMapForSource)\Binaries" stopOnError="true"/>
  <folder section="PreBuild" action="create" force="true" path="$(DriveToMapForSource)\Working" stopOnError="true"/>
  <message section="PreBuild" action="console" text=" 10 » Box is now setup for build....." newLine="true"/>
  
  <!-- ========================================== -->
  <!-- SECTION(20) Pre Build - Getting the source code. 
  This section creates some of the folders that are specfically required for the build and 
  then performs a get from the vault repository for the sample application.  
  This should have the effect of getting all of the source code ready to be built down to 
  the target workstation.
  -->
  <!-- ==========================================  -->
  <message section="PreBuild" action="console" text="SECTION(30) - Pre Build - Getting the source code." newLine="true"/>
  
  <message section="PreBuild" action="console" text="		30.1 » Creating working folders" newLine="true"/>
  <folder action="create" force="true" path="$(DriveToMapForSource)\Working\Code" stopOnError="true"/>
  <folder action="create" force="true" path="$(DriveToMapForSource)\Working\Output" stopOnError="true"/>
  
  <message section="PreBuild" action="console" text="		30.2 » Performing GET from code repository" newLine="true"/>

  <sourceControl section="BuildStart" action="get" stopOnError="true" 
    system="vault" repository="$(VaultRepository)" 
    isBoundToIde="false" project="$(VaultSolutionPath)" destDir="$(DriveToMapForSource)\Working\Code"/>
  <message section="PreBuild" action="console" text="		30	 » Complete" newLine="true"/>
  
  <!-- ================================================================== -->
  <!-- SECTION(35) Perform Versioning.
  This section will run the version number 2 element to update the solution with the 
  correct versioning information.  The process for applying versioning using version 
  number 2 involves getting a version fragment from somewhere (in this case vault) 
  and then applying the versioning using this fragment.  
  To keep the changes the versioning fragment is then checked back into vault. -->
  
 <!-- ================================================================== -->
 <message section="versioning" action="console" text="SECTION(35) - Apply Versioning " newLine="true"/>
  
  <folder action="create" force="true" path="$(DriveToMapForSource)\Working\Versioning" stopOnError="true"/>
   <message section="versioning" action="console" text="		35.1 » Checking OUT Versioning Fragment" newLine="true"/>

  <sourceControl section="versioning" system="vault" action="checkout" 
        stopOnError="true" repository="$(VaultRepository)" isBoundToIde="false"
        project="$(VaultURLOfVersioningFragment)" destDir="$(DriveToMapForSource)\Working\Versioning" 
        sourceControlComment="Build tool, checking out versioning fragment for daily build."/>

    <!-- Note SaveVersioningFragment =true, this ensures that the changes the versioning 
        component makes are saved back out to the versioning fragment so that it works 
        next time, also notice the Major and Minor overrides alter the values in the 
        versioning fragment to those that are defined at the top of the build script -->
	<message section="versioning" action="console" text="		35.2 » Incrementing verion" newLine="true"/>
 
    <versionNumber2 section="versioning" versioningFragmentLocation="$(DriveToMapForSource)\Working\Versioning\$(VersioningFragmentFilename)" 
                  stopOnError="true" SaveVersioningFragment="true" versionName="$(ScriptVersionName)" MajorOverride="$(MajorVersionNo)" MinorOverride="$(MinorVersionNo)">
    <FilenamesToReplaceAssemblyFileVersion>
      <fileNames filename="$(DriveToMapForSource)\Working\Code\Business Services\HBOS.FS.AMP.UPD.Controllers\Common\BuildAssembly.cs" />
      <fileNames filename="$(DriveToMapForSource)\Working\Code\Business Services\HBOS.FS.AMP.UPD.Persistence\Common\BuildAssembly.cs" />
      <fileNames filename="$(DriveToMapForSource)\Working\Code\HBOS.FS.AMP.UDP.Security\Common\BuildAssembly.cs" />
      <fileNames filename="$(DriveToMapForSource)\Working\Code\Solution Types\HBOS.FS.AMP.UPD.Exceptions\Common\BuildAssembly.cs" />
      <fileNames filename="$(DriveToMapForSource)\Working\Code\Solution Types\HBOS.FS.AMP.UPD.Types\Common\BuildAssembly.cs" />
      <fileNames filename="$(DriveToMapForSource)\Working\Code\User Services\HBOS.FS.AMP.UPD.WinUI\Common\BuildAssembly.cs" />
      <fileNames filename="$(DriveToMapForSource)\Working\Code\User Services\HBOS.FS.AMP.UPD.WinUI.Library\Common\BuildAssembly.cs" />
      <fileNames filename="$(DriveToMapForSource)\Working\Code\User Services\HBOS.FS.AMP.UPD.WinUI.Reports\Common\BuildAssembly.cs" />
            <fileNames filename="$(DriveToMapForSource)\Working\Code\User Services\CustomInstaller\Common\BuildAssembly.cs" />
    </FilenamesToReplaceAssemblyFileVersion>
    <FilenamesToReplaceAssemblyVersion>
      <fileNames filename="$(DriveToMapForSource)\Working\Code\Business Services\HBOS.FS.AMP.UPD.Controllers\Common\ReleaseAssemblyInfo.cs" />
      <fileNames filename="$(DriveToMapForSource)\Working\Code\Business Services\HBOS.FS.AMP.UPD.Persistence\Common\ReleaseAssemblyInfo.cs" />
      <fileNames filename="$(DriveToMapForSource)\Working\Code\hbos.fs.amp.udp.Security\Common\ReleaseAssemblyInfo.cs" />
      <fileNames filename="$(DriveToMapForSource)\Working\Code\Solution Types\HBOS.FS.AMP.UPD.Exceptions\Common\ReleaseAssemblyInfo.cs" />
      <fileNames filename="$(DriveToMapForSource)\Working\Code\Solution Types\HBOS.FS.AMP.UPD.Types\Common\ReleaseAssemblyInfo.cs" />
      <fileNames filename="$(DriveToMapForSource)\Working\Code\User Services\HBOS.FS.AMP.UPD.WinUI\Common\ReleaseAssemblyInfo.cs" />
      <fileNames filename="$(DriveToMapForSource)\Working\Code\User Services\HBOS.FS.AMP.UPD.WinUI.Library\Common\ReleaseAssemblyInfo.cs" />
      <fileNames filename="$(DriveToMapForSource)\Working\Code\User Services\HBOS.FS.AMP.UPD.WinUI.Reports\Common\ReleaseAssemblyInfo.cs" />
            <fileNames filename="$(DriveToMapForSource)\Working\Code\User Services\CustomInstaller\Common\ReleaseAssemblyInfo.cs" />
    </FilenamesToReplaceAssemblyVersion>
  </versionNumber2>

  <message section="versioning" action="console" text="			35.5 » Checking IN Versioning Fragment" newLine="true"/>
  <sourceControl section="versioning" system="vault" action="checkin" stopOnError="true" repository="$(VaultRepository)" isBoundToIde="false"
        project="$(VaultURLOfVersioningFragment)" destDir="$(DriveToMapForSource)\Working\Versioning\"
        sourceControlComment="Build Tool, checking versioning fragment back in for daily build.  VerNo: $(VersionNumber) and VerName: $(VersionName)"/>

  <!-- Get the latest install project, check out and increment the version number and GUID's -->
  <message section="versioning" action="console" text="		35.6 » Checking OUT Installer Project" newLine="true"/>

  <sourceControl section="" system="vault" action="checkout" 
        stopOnError="false" repository="$(VaultRepository)" isBoundToIde="false"
        project="$(VaultURLOfInstallerProject)" destDir="$(DriveToMapForSource)\Working\Code\Installer" 
        sourceControlComment="Build tool, checking out Installer project for daily build to increment project GUID."/>
  
  <!-- Now execute EXE to assign unique GUIDs and increment the installer version number -->
  <message section="versioning" action="console" text="		35.7 » Applying version to installer and assigning unique GUID's" newLine="true"/>
  <message section="versioning" action="console" text="		35.8 » Installer project filename: $(DriveToMapForSource)\Working\Versioning\$(InstallerProjectFilename)" newLine="true"/>
  
  <run section="" path="$(InstallerVersioningPath)\VersionVDProj.exe" parameters="-msi $(DriveToMapForSource)\Working\Code\Installer\$(InstallerProjectFilename) version=$(VersionNumber)"/>  
  
  <message section="versioning" action="console" text="			35.8 » Checking IN Installer Project" newLine="true"/>
  <sourceControl section="" system="vault" action="checkin" stopOnError="true" repository="$(VaultRepository)" isBoundToIde="false"
        project="$(VaultURLOfInstallerProject)" destDir="$(DriveToMapForSource)\Working\Code\Installer"
        sourceControlComment="Build Tool, checking Installer project back in for daily build."/>

  <message section="versioning" action="console" text="			35   » Versioning Complete : information : VerNo: $(VersionNumber) and VerName: $(VersionName)" newLine="true"/>
 
 <!-- ============================================ -->
 <!-- SECTION(40) Perform Build - 
 This section physically calls visual studio to actually perform the build for us.  
 Visual studio is invoked in such a way that the output of the
 build is redirected to the location specified in the attributes.  
 This lets us find out what went wrong if the build fails for any reason. -->
 <!-- ============================================ -->
 <message action="console" text="SECTION(40) - Solution build stage" newLine="true"/> 
 <message section="versioning" action="console" text="		40.1 » Building the $(ConfigurationToBuild) version of $(SolutionFilename)" newLine="true"/>
 <solution section="" stopOnError="true" action="build" visualStudio="7.1" 
    path="$(DriveToMapForSource)\Working\Code\$(SolutionFilename)" 
    config="$(ConfigurationToBuild)" clean="true" 
    overrideOutputDirectory="$(DriveToMapForSource)\Working\Output"/>
    
 <message action="console" text="		40   » Build Completed" newLine="true"/>

 <message action="console" text="SECTION(45) - Solution label stage" newLine="true"/> 
 <message section="PerformLabelling" action="console" text="		45.1 » Labelling solution 'label = $(ProjectTitle). Version - $(VersionNumber)'" newLine="true"/>
 <run section="labelSolution" 
	path="$(LabelBatchFile)" 
	parameters='"$(VaultRepository)" "$(VaultSolutionPath)" "Auto Build - version $(VersionNumber)"'
	waitForExit="true"/>
 <message action="console" text="		45   » Label Completed" newLine="true"/>  
  
 <!-- ========================================== -->
  <!-- SECTION(50) Relocate binaries 
  This section will take the binary outputs of the build and place 
  them in the output directory.  This has the side effect of flattening the directory
  structure that is used to cause the build - for some solutions this will not be an 
  appropriate action but instead just the main exe output directory 
  should be copied.  For this very simple application it does not matter.
  Relocate binarys effectivly performs an xcopy with some fancy options 
  to help build developers.
  -->
  <!-- ==========================================  -->
  <message action="console" text="SECTION(50) - Copying binarys" newLine="true"/>
  
  <message action="console" text="		50.1 » Copy to $(DriveToMapForSource)\Working\Output" newLine="true"/>
  <relocateBinaries sourceDir="$(DriveToMapForSource)\Working\Code" 
    destDir="$(DriveToMapForSource)\Working\Output"  
    copyOptions="copyExesDllsXmlsOnly" 
    directoryParsingOptions="skipObjDirs" 
    overwriteOptions="overwriteTargetFilesEvenIfReadonly"/>  
  
  <!-- SECTION 50.2, copy binaries.  
  This could be a copy to another server or another location or 
  whatever - however this simple script just copies
  the outputs to the binarys folder within the mapped drive. -->
  <message action="console" text="		50.2 » copy to $(DriveToMapForSource)\Binaries" newLine="true"/>
  <run section="" path="%WINDIR%\System32\xcopy.exe" parameters="$(DriveToMapForSource)\Working\Output\*.* $(DriveToMapForSource)\Binaries /E /Y /I /R"/>
  <message action="console" text="		50   » Binaries copied" newLine="true"/>

  <!-- ========================================== -->
  <!-- SECTION(60) Building output using NDOC -->
  <message action="console" text="SECTION(60) - Generating NDOC output" newLine="true"/>
  <message action="console" text="		60.1 » Executing $(NDocBinariesPath)\NDocConsole.exe" newLine="true"/>
    <run section="" 
        path="$(NDocBinariesPath)\NDocConsole.exe" 
        parameters="-project=$(DriveToMapForSource)\Working\Code\$(ProjectTitle).ndoc" />  
		
    <!-- Copy NDOC results to output directory -->
    <message action="console" text="		60.2 » copying new NDOC output to $(NDOCOutput)" newLine="true" />
    <run section="NDOC Copy" path="%WINDIR%\System32\Xcopy.exe" parameters="$(NDOCOutput)\*.* $(ProjectStatusPhysicalDirectory)\NDOC /E /Y /I /R "/>
    <message action="console" text="		60   » NDOC files generated" newLine="true"/>

	<!-- ========================================== -->
	<!-- SECTION(70) Building FXCOP output -->
	<!--
	<message action="console" text="SECTION(70) - Generating FXCop output" newLine="true"/>

	<folder section="fxcop" action="create" force="true" path="$(DriveToMapForSource)\FxCopOutput" stopOnError="false"/>
	<fxCop 
		section="fxcop"
		stopOnError="false"
		smtpServer="" 
		solutionPath="$(DriveToMapForSource)\Binaries" 
		projectFilePath="$(DriveToMapForSource)\FxCopOutput\UPD.FxCop" 
		projectTemplateFilePath="$(DriveToMapForSource)\Working\Code\UPD.FxCop" 
		outFileName = "$(DriveToMapForSource)\FxCopOutput\FxCopOutput.xml"
		fxCopNotifyExe="" 
		ownersXmlFile="$(DriveToMapForSource)\Working\Code\NamespaceOwners.xml" 
		xslFile="$(DriveToMapForSource)\FxCopOutput\FxCopReport.xsl" 
		xslReferenceLocation="$(ProjectStatusVirtualDirectory)/FxCopReport.xsl">
		<exclusions>
			<exclusion assembly="nunit.framework.dll" />
			<exclusion assembly="HBOS.FS.Support.Tex.dll" />
			<exclusion assembly="HBOS.FS.Common.ExceptionManagement.dll" />
			<exclusion assembly="HBOS.FS.Data.FileReaders.dll" />
			<exclusion assembly="HBOS.FS.AMP.ExceptionManagement.dll" />
			<exclusion assembly="HBOS.FS.AMP.Configuration.dll" />
		</exclusions>
	</fxCop>
	-->
	<!-- Remove the previous FxCop output -->
	<!--
	<message action="console" text="		70.1 » deleting old FXCop output from $(ProjectStatusPhysicalDirectory)\FxCop\FxCopOutput.xml" newLine="true" />
	<file action="delete" path="$(ProjectStatusPhysicalDirectory)\FxCop\FxCopOutput.xml" force="true" stopOnError="true" />
    <message action="console" text="		70   » complete" newLine="true"/>
	-->
	
	<!-- ========================================== -->
  <!-- Copy the documentation over to our virtual directory -->
  <message action="console" text="SECTION(80) - Copying documentation" newLine="true"/>
  <run section="" path="%WINDIR%\System32\xcopy.exe" parameters="$(DriveToMapForSource)\FxCopOutput\*.* $(ProjectStatusPhysicalDirectory)\FxCop /E /Y /I /R"/>
  <run section="" path="%WINDIR%\System32\xcopy.exe" parameters="$(DriveToMapForSource)\NDocOutput\*.* $(ProjectStatusPhysicalDirectory)\NDoc /E /Y /I /R"/>
  <run section="" path="%WINDIR%\System32\xcopy.exe" parameters="$(DriveToMapForSource)\Versioning\$(VersioningFragmentFilename) $(ProjectStatusPhysicalDirectory) /E /Y /I /R"/>
  <run section="" path="%WINDIR%\System32\xcopy.exe" parameters="$(DriveToMapForSource)\Output\*.log $(ProjectStatusPhysicalDirectory) /E /Y /I /R"/>
  <run section="" path="%WINDIR%\System32\xcopy.exe" parameters="$(DriveToMapForSource)\Output\*.txt $(ProjectStatusPhysicalDirectory) /E /Y /I /R"/>
  <message action="console" text="		80   » complete" newLine="true"/>

  <!-- ================================================================== -->
  <!-- Release the finished assemblys out to a release folder -->
  <!-- ================================================================== -->
  <!-- SECTION (90) -->
  <message action="console" text="SECTION(90) - Releasing the finished assemblies" newLine="true"/>
  <!--Create ourselves a destination folder and copy our binaries to it.-->

  <message action="console" text="		90.1 » Copying to release folder..." newLine="true"/>
  <folder section="CopyOutputToReleaseDir" action="create" force="true" path="$(BuildServerReleasePath)\$(ProjectTitle)" stopOnError="true"/>
  <folder section="CopyOutputToReleaseDir" action="create" force="true" path="$(BuildServerReleasePath)\$(ProjectTitle)\DailyBuilds\$(ScriptVersionName)_$(VersionNumber)" stopOnError="true" />

  <message action="console" text="		90.2 » Creating release folder for $(ProjectTitle)" newLine="true"/>
  <run section="" path="%WINDIR%\System32\xcopy.exe" parameters="$(DriveToMapForSource)\Binaries\*.* $(BuildServerReleasePath)\$(ProjectTitle)\DailyBuilds\$(ScriptVersionName)_$(VersionNumber)\Binaries  /E /Y /I /R"/>
  <run section="" path="%WINDIR%\System32\xcopy.exe" parameters="$(DriveToMapForSource)\Output\*.* $(BuildServerReleasePath)\$(ProjectTitle)\DailyBuilds\$(ScriptVersionName)_$(VersionNumber)\Output  /E /Y /I /R" />
  <run section="" path="%WINDIR%\System32\xcopy.exe" parameters="$(DriveToMapForSource)\Working\Code\Installer\*.* $(BuildServerReleasePath)\$(ProjectTitle)\DailyBuilds\$(ScriptVersionName)_$(VersionNumber)\Package  /E /Y /I /R"/>
  <run section="" path="%WINDIR%\System32\xcopy.exe" parameters="$(NDOCOutput)\*.* $(BuildServerReleasePath)\$(ProjectTitle)\DailyBuilds\$(ScriptVersionName)_$(VersionNumber)\NDoc  /E /Y /I /R"/>
  <folder section="PostBuild" action="delete" force="true" path="$(NDOCOutput)" stopOnError="false"/>
  <message action="console" text="		90   » complete" newLine="true"/>

  <!-- ========================================== -->
  <!-- SECTION(100) Execute NUnit scripts -->
  <message action="console" text="SECTION(100) - Generating unit tests" newLine="true"/>
  <message action="console" text="		100	» Execute solution types unit tests" newLine="true"/>
  
<!--    <run section="" 
        path="C:\$(NUnitBinariesPath)\nunit-console" 
        parameters="$(DriveToMapForSource)\Working\Code\Solution Types\$(ProjectUnitTestNameSpace).Types\bin\Release\HBOS.FS.AMP.Entities.dll /xml:$(BuildServerReleasePath)\$(ProjectTitle)\DailyBuilds\$(ScriptVersionName)_$(VersionNumber)\Output\NUnit-solutionTypes-test.xml /transform:$(DriveToMapForSource)$(NUnitTransform)\Summary.xslt" 
    />  -->

    <!-- This is the full path without the XSLT variables -->
    <!-- C:\Program Files\NUnit 2.2\bin\nunit-console -->
    <!-- /xml:C:\UPDBuildTool\ReleasePath\UPD\DailyBuilds\DailyBuild_1.2.32.1\Output\NUnit-solutionTypes-test.xml -->
    <!-- /transform:s:\Working\Code\Build\Summary.xslt -->
  
    <message action="console" text="		100 » Unit tests complete" newLine="true"/>

  <!-- ========================================== -->
  <!-- SECTION(00) End build
  This section is not strictly necessary but it does help the build script 
  if you can tell it that the build has ended so that it can clean up any resources.
  If you do not do this then resources are not lost but they are left for the .net 
  framework finalisers to clear up.
  The parameter is not currently used, however it may be in the future.
  -->
    <message action="console" text="SECTION(00) - Auto Build Finished" newLine="true"/>
  <!-- ==========================================  -->
  <endScript aparameter="Reserved"/>
</build>