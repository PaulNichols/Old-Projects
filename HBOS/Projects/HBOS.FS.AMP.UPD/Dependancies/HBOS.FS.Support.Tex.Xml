<?xml version="1.0"?>
<doc>
    <assembly>
        <name>HBOS.FS.Support.Tex</name>
    </assembly>
    <members>
        <member name="T:HBOS.FS.Support.Tex.TraceCommandTypes">
            <summary>
            Trace Command Types - represent all of the possible command types that can be issued as a trace command.
            </summary>
        </member>
        <member name="T:HBOS.FS.Support.Tex.KnownCommands">
            <summary>
            Known Commands represent commands that can be sent directly to the viewer
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.KnownCommands.IncreaseIndent">
            <summary>
            Tell the viewer to increase the indent level on the following outputs
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.KnownCommands.DecreaseIndent">
            <summary>
            Tell the viewer to decrease the indent level on the following outputs
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.KnownCommands.PurgeAll">
            <summary>
            Tell the viewer to remove all curent trace data from its store
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.KnownCommands.PurgeCurrent">
            <summary>
            Tell the viewer to remove all current trace data for thsi current process from its store
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.KnownCommands.DontLeaveLine">
            <summary>
            Tell the viewer not to leave a line between this entry and the next entry.
            </summary>
        </member>
        <member name="T:HBOS.FS.Support.Tex.TraceCommands">
            <summary>
            Trace commands represents further information about the trace commands themselvers
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.TraceCommands.TraceCommandToReadableString(HBOS.FS.Support.Tex.TraceCommandTypes)">
            <summary>
            This will take the trace command enum and turn each of the valid entries into a readable string that is suitable
            to be printed on the screen or displayed to the user.
            </summary>
            <param name="tct">The trace command types enum selected and valid value</param>
            <returns>string representing that value</returns>
        </member>
        <member name="T:HBOS.FS.Support.Tex.TraceConstants">
            <summary>
            Class holding all of the constants that are used by the trace program.
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.TraceConstants.DEPTHPROTECTION">
            <summary>
            Loops that are based on recursion have depth protection enabled so that an assign innter to outer style
            nastyness does not break tex.  The output will be very ugly but it will be better to a stackoverflow
            excepiton, or nasty infinite looping thing.
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.TraceConstants.EVIDENCENAMELENGTH">
            <summary>
            there is a limit to display text, this is most prevalant in evidence names which are built up from type names
            and therefore can easily exceed the length that they are sposed to be at.  This just visciously truncates them
            at that length.
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.TraceConstants.EXCEPTIONENDTAG">
            <summary>
            Internal identifier to mark the end of an exception set of log messages
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.TraceConstants.CMD_INCREASEINDENT">
            <summary>
            Command string to increase the indent of the viewer that is attached
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.TraceConstants.CMD_DECREASEINDENT">
            <summary>
            Command string to decrease the indent of the viewer that is attached
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.TraceConstants.CMD_DONTLEAVELINE">
            <summary>
            Command string to indicate to the viewer that no line should be left between this statement and the next
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.TraceConstants.CMD_CAUSEPURGEINCURRENT">
            <summary>
            Command string for the viewer to indicate that a purge of the current process should be performed
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.TraceConstants.CMD_CAUSEGLOBALPURGE">
            <summary>
            Command string for the viewer to indicate that a global purge should be performed
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.TraceConstants.ODSLISTNER_NAME">
            <summary>
            The name of the specific Output debug string listener 
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.TraceConstants.FILELISTNER_NAME">
            <summary>
             The name of the external text writer listener
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.TraceConstants.CONLISTNER_NAME">
            <summary>
            The name for the console listener
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.TraceConstants.DEFLISTNER_NAME">
            <summary>
            The name for the default listener
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.TraceConstants.ORIGINALLISTENER_NAME">
            <summary>
            The name for the VS.Net 2003 default listener
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.TraceConstants.NFI">
            <summary>
            The internal string used when no further infromation is available.
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.TraceConstants.TRCCLASSEXCEPTIONS">
            <summary>
            Array of the internal class names for trace dependant classes so that the stack trace commands
            can identify the areas which are not part of the internal structure for their logging
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.TraceMessageFormat.ReturnPartsOfString(System.String,System.String@,System.String@,System.String@,System.String@,System.String@,System.String@,System.String@)">
            <summary>
            This identifys the internal structure of the trace message.  The helper functions here
            depend on this internal structure and are all kept here.  There should be no dependance
            on the structure of the string outside of thsi class.
            
            {[MACHINENAME][PROCESSID][THREADID][MODULENAME][LINENUMBER]}#CMD#TEXTOFDEBUGSTRING
            
            Where MACHINENAME = Current machine name taken from Environment
            Where PROCESSID   = The PID assigned to the process that outputed the string
            where THREADID    = The numeric ID assigned to the OS Thread running the commands
            where MODULENAME  = The cs filename that was executing the commands
            where LINENUMBER  = the numeric line number that the debug string was written from
            
            NB Future enhancement 1 :
            [NETTHREADNAME]   = The name of the .net thread running the command.  
            </summary>  
        </member>
        <member name="T:HBOS.FS.Support.Tex.AnEvidence">
            <summary>
            When the error dialog is created for the T.Error method the addittional information slots
            are populated using instances of AnEvidence class.  Each evidence has a text name and 
            a description.  The name should be kept short to be displayed on the form and the theText should
            contain all of the required information separated frequently using newlines
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.AnEvidence.TheName">
            <summary>
            The name of the piece of evidence.
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.AnEvidence.TheText">
            <summary>
            The full description of the evidence itself
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.AnEvidence.ToString">
            <summary>
            To string returns the name of the evidence
            </summary>
            <returns>The displayable name of the evidence</returns>
        </member>
        <member name="M:HBOS.FS.Support.Tex.AnEvidence.#ctor(System.String,System.String)">
            <summary>
            Constructor override to supply the name and the evidence in one
            </summary>
            <param name="name">The name of the evidence that is to be supplied.  Cannot be null</param>
            <param name="text">The full text of the evidence that is to be supplied.  If this is null the text null will be displayed</param>
        </member>
        <member name="T:HBOS.FS.Support.Tex.DefaultListenerErrorDialog">
            <summary>
            Summary description for DefaultListenerErrorDialog.
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.DefaultListenerErrorDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.DefaultListenerErrorDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.DefaultListenerErrorDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:HBOS.FS.Support.Tex.Listeners.DefaultListernerAssertionDialog">
            <summary>
            Summary description for DefaultListernerAssertionDialog.
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.Listeners.DefaultListernerAssertionDialog.components">
            <summary>
            Required designer variable.
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.DefaultListernerAssertionDialog.#ctor(System.String,System.String,System.String,System.String,System.String,System.String,System.String)">
            <summary>
            This will create the default listener assertion dialog which will provide a slightly better formatted display
            of assertion than the original messagebox.
            </summary>
            <param name="errorText">The main error text of the assertion</param>
            <param name="stacktrace">The stack trace text of the assertion</param>
            <param name="machineid">The identifier of the machine that raised the assertion</param>
            <param name="processid">The process id of the raising process</param>
            <param name="threadid">The thread ID of the thread on which the assertion occured</param>
            <param name="moduleName">The module - available from the PDB data</param>
            <param name="line">The Line number - available from PDB Data</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.DefaultListernerAssertionDialog.Dispose(System.Boolean)">
            <summary>
            Clean up any resources being used.
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.DefaultListernerAssertionDialog.InitializeComponent">
            <summary>
            Required method for Designer support - do not modify
            the contents of this method with the code editor.
            </summary>
        </member>
        <member name="T:HBOS.FS.Support.Tex.Listeners.TexDefaultListener">
            <summary>
            The default listener is designed to be used in conjunction with the trace viewer
            and will output thread and process information along with the messages.  The listener
            also allows for control messages and additional messages.
            NB tested to be thread safe but not coded for. For full thread support use VS2003 TextWriterListener and import to mex later.
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.Listeners.TexDefaultListener.MYNAME">
            <summary>
            The name of the default listener
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.TexDefaultListener.Fail(System.String)">
            <summary>
            Override for an assertion failure
            </summary>
            <param name="theMessage"></param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.TexDefaultListener.Fail(System.String,System.String)">
            <summary>
            override for an assertion failure with two parameters
            </summary>
            <param name="theMessage"></param>
            <param name="theMessage2"></param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.TexDefaultListener.Write(System.String)">
            <summary>
            override for a write to the trace stream
            </summary>
            <param name="message">the message</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.TexDefaultListener.WriteLine(System.String)">
            <summary>
            override for a writeline to the trace strea,
            </summary>
            <param name="message">the message</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.TexDefaultListener.#ctor">
            <summary>
            The Tex default trace listener constructor.  This is designed to talk to the Mex viewer during development.
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.TexDefaultListener.#ctor(System.String)">
            <summary>
            The Tex default listener constructor - dummy for compat with config files
            </summary>
            <param name="init"></param>
        </member>
        <member name="P:HBOS.FS.Support.Tex.Listeners.TexDefaultListener.Name">
            <summary>
            override to retrieve the name of the trace listener
            </summary>
        </member>
        <member name="T:HBOS.FS.Support.Tex.Listeners.TrcConsoleListener">
            <summary>
            Console listener implemented to output LPSTrace related statements to the console. 
            Designed to be used when a console window is used by the application for debugging, it is
            unwise to do this where the main application is a console application as the trace output
            can get quite large. 
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.Listeners.TrcConsoleListener.MYNAME">
            <summary>
            The name of the console listener.
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.TrcConsoleListener.Fail(System.String)">
            <summary>
            Console listener Fail overide.  Used to write assertion failures to the screen.  
            </summary>
            <param name="message">Text of the string to describe the failure</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.TrcConsoleListener.Fail(System.String,System.String)">
            <summary>
            Console Listener fail override, two string parameters.  Used to write assertion failures to the screen.
            </summary>
            <param name="message1">The first string </param>
            <param name="message2">The more info string</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.TrcConsoleListener.Write(System.String)">
            <summary>
            Console listener override for the Write function to write a trace message to the screen.
            </summary>
            <param name="message">Text to be written</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.TrcConsoleListener.WriteLine(System.String)">
            <summary>
            Console listener override to write a trace message to the screen
            </summary>
            <param name="message">Text to be written</param>
        </member>
        <member name="P:HBOS.FS.Support.Tex.Listeners.TrcConsoleListener.Name">
            <summary>
            Console listener override of the name parameter of the listener
            </summary>
        </member>
        <member name="T:HBOS.FS.Support.Tex.Listeners.TrcDebuggerLogListner">
            <summary>
            This listener outputs its data to the registered debugger and will log data to it,
            this can rapidly become unwieldy as the vs debugger log window is very small and it
            can be hard to make out the trace specific data there.
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.TrcDebuggerLogListner.Fail(System.String)">
            <summary>
            override for the fail method of the trace listener base class
            </summary>
            <param name="message">The failure message</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.TrcDebuggerLogListner.Fail(System.String,System.String)">
            <summary>
            Two string override for the fail method of the trace listener base class
            </summary>
            <param name="message1">the first message</param>
            <param name="message2">further information</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.TrcDebuggerLogListner.Write(System.String)">
            <summary>
            Override for the write message of the trace listener base class
            </summary>
            <param name="message">the trace message</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.TrcDebuggerLogListner.WriteLine(System.String)">
            <summary>
            Override for the writeline method of the trace listener base class
            </summary>
            <param name="message">The message</param>
        </member>
        <member name="P:HBOS.FS.Support.Tex.Listeners.TrcDebuggerLogListner.Name">
            <summary>
            Override to return the name of this listneer
            </summary>
        </member>
        <member name="T:HBOS.FS.Support.Tex.Listeners.AssertionException">
            <summary>
            An AssertionException type is thrown when a Tex assertion failure condition is met or when a breach failure
            condition is met.  These excetpion types derrive from System.Execption directly and should not generally be caught.
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.AssertionException.#ctor(System.String)">
            <summary>
            Constructor with a single message string for the assertion exception. NB the assertion exception is not designed to be caught.
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.AssertionException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor using an inner exception for the asssertion exception.  NB the assertion exception is not designed to be caught.
            </summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.AssertionException.#ctor">
            <summary>
            Default constructor with no parameters for the assertion exception.  NB the assertion exception is not designed to be caught.
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.AssertionException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Default constructor to provide compatibility with exceptions in general - this overriden one hands on to the base.
            </summary>
            <param name="si">The serialisation information</param>
            <param name="sc">The streaming context</param>
        </member>
        <member name="T:HBOS.FS.Support.Tex.Listeners.TraceListenerUtils">
            <summary>
            Static class that holds utilities that can be used by all of the different listeners.
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.TraceListenerUtils.StripTraceInfo(System.String)">
            <summary>
            The strings that are used by the listeners have special formatting information at the front
            of them to indicate the process, thread and type of information that is held by the string.  This
            method strips that information from the string.
            </summary>
            <param name="inward">Fully formed string containing trace specific data</param>
            <returns>raw string alone - having the trace specific data removed</returns>
        </member>
        <member name="T:HBOS.FS.Support.Tex.Listeners.TrcWinODSListener">
            <summary>
            This will output all data directly to the ODS listener - it is designed for inteception
            by default debugging listeners that are not specifically tuend to LPSTrace and therefore
            strips the majority of additional information from the data before it sends it.
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.Listeners.TrcWinODSListener.MYNAME">
            <summary>
            The name of this listener
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.TrcWinODSListener.Fail(System.String)">
            <summary>
            The fail override for the trace listener base fail fucntion
            </summary>
            <param name="message">the message</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.TrcWinODSListener.Fail(System.String,System.String)">
            <summary>
            The fail override for the base tracelistener fail function
            </summary>
            <param name="message1">the message</param>
            <param name="message2">further information</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.TrcWinODSListener.Write(System.String)">
            <summary>
            The override for the base tracelistener write function
            </summary>
            <param name="message">The message</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.Listeners.TrcWinODSListener.WriteLine(System.String)">
            <summary>
            Override for the base tracelistner writeline function
            </summary>
            <param name="message"></param>
        </member>
        <member name="P:HBOS.FS.Support.Tex.Listeners.TrcWinODSListener.Name">
            <summary>
            Override for the base tracelistener name function
            </summary>
        </member>
        <member name="T:HBOS.FS.Support.Tex.NoDependsCopy.JimUtils">
            <summary>
            Summary description for JimUtils.
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.NoDependsCopy.JimUtils.MakeManyStrings(System.String,System.Int32)">
            <summary>
            This will take a single long string and return it as a series of truncated strings with the length that is 
            specified in theLength parameter used to do the chopping up.  There is nothing clever or special about this 
            routine it does not break on words or aynthing like that.
            </summary>
            <param name="theLongString">The string that is to be chopped up into smaller strings</param>
            <param name="theLength">The length at which the smaller strings are to be created</param>
            <returns></returns>
        </member>
        <member name="M:HBOS.FS.Support.Tex.NoDependsCopy.JimWin32Interface.FormatError(System.Int32)">
            <summary>
            Specific override to provide a format from an error code.  This will call the format Message API function for the given
            error code with the correct parameters.
            </summary>
            <param name="errCode">The win32 error code to look up the message for</param>
            <returns>The string representing the error message</returns>
        </member>
        <member name="T:HBOS.FS.Support.Tex.TexException">
            <summary>
            An assert exception is thrown when the Trace application cannot get input from the user as to how to
            behave in an assertion situation.  Therefore if there is no visible display of an assertion one of these
            exceptions is thrown.  It should NEVER be caught and code reviews should check for the catching of 
            trace assertion exception.
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.TexException.#ctor(System.String)">
            <summary>
            This Assertion exception should not be caught.  IT is designed to flag up assertion failures to 
            developing code and should not be used in production code.   It is thrown by AssertE or when an
            assertion is called when there is no valid user interface.
            </summary>
            <param name="s"></param>
        </member>
        <member name="T:HBOS.FS.Support.Tex.TexAssertionException">
            <summary>
            An Assertion exception is thrown when an assertion fails on a non interactive process
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.TexAssertionException.#ctor(System.String)">
            <summary>
            Default override for one message
            </summary>
            <param name="s">the message</param>
        </member>
        <member name="T:HBOS.FS.Support.Tex.TexBreachException">
            <summary>
            Exception that is thrown when a breach condition fails.  
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.TexBreachException.#ctor(System.String)">
            <summary>
            The default constructor for a TexBreachException
            </summary>
            <param name="s">string describing the reason for the breach failure</param>
        </member>
        <member name="T:HBOS.FS.Support.Tex.T">
            <summary>
            <para>TexTrace class impelementation provides debugging, tracing and assertion assistance. The class consists of
            a series of static methods to provide tracing and logging functions.  The majority of the class is compiled using
            the DEBUG conditional symbol and therefore will only be available during DEBUG builds.</para>
            <para>TexTrace is designed to work with custom trace viewers that can read the output streams that it generates.  It
            uses the default tracing mechanism of the .net framework for writing trace information but prefixes messages with its 
            own internal data and therefore custom viewers should be used to get the greatest advantage of Tex.</para>
            <para>The level of logging is altered primarily using the CurrentTraceLevel property which can set the logging according
            to the default trace level enum.</para>
            </summary>
        </member>
        <member name="F:HBOS.FS.Support.Tex.T.m_initialisationOccured">
            <summary>
            This is used to reduce the effect of calling initialise twice.  When initialise is called twice it can
            reset the view in some viewers meaning that initialise cannot be called for ASP applications.  This will
            prevent this from happening.  
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.RecurseObject(System.Object,System.String)">
            <summary>
            This is a helper routine for the DumpObjectDeep routine - this is called once for each of the nested objects
            which are then written out to the stream as a series of more infos.  This can only be called once the dump object
            deep routine has been begun otherwise the moreinfos are attached to the wrong place.  currently does not support
            arrays
            This method is only present when the DEBUG contiditional is specified
            </summary>
            <param name="obj">The object graph to dump to the stream</param>
            <param name="prefix">the level of indentation in a prefix format</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.IsCallingAssemblyInDebugMode(System.Reflection.Assembly)">
            <summary>
            This is not a correct implementation.  However in order for the Breach methods to determine whether they should throw
            assertions or exceptions I have implemented this.  Ideally you would be able to check whether it was in debug or release
            mode that the calling assembly was, however Im not sure that you can therefore this method will look for the debuggable
            attribute in the calling assembly. If it is present it will assume that the caller is in debug mode.
            </summary>
            <returns></returns>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.TranslateTypeNamesToCSharp(System.String)">
            <summary>
            Helper function to convert system type names to their C# equivalents.  Used to format output to a c# style
            although generally unnecessary can help flavour output.
            </summary>
            <param name="typeName">The .net typename of the variable to convert.</param>
            <returns>The c# specific typename corresponding to the .net type</returns>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.IncludeThisMethodInOutput(System.Diagnostics.TraceLevel)">
            <summary><para>
            This method will compare the requested method level against the current internal level of the trace object and decide
            whether or not the message should be outputted to the stream.  This does not determine the level but applies it to the
            trace requests that are made.</para>
            <remarks>This method is private.</remarks>
            </summary>
            <param name="methodsLevel">The trace level of the command that is about to be written.</param>
            <returns>True if the request should be processed, false otherwise</returns>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.StackFrameAboveThisOne">
            <summary>
            This private method returns a method stackframe for the method above the calling method.  Therefore it will return you 
            a stack frame of the method that called you.  
            </summary>
            <returns>A StackFrame representing your caller</returns>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.GetModuleBeforeTexTrace(System.String@)">
            <summary>
            This is a shortcut routine to calling the GetStackInfoBeforeTraceClass - as it will dummy out most of the returns
            from this other function and only reutrn the line and filename.
            </summary>
            <param name="lineNumber">The line number that the code was executed on</param>
            <returns>The module (filename) where the code was called from</returns>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.MessageRouter(System.String,System.String,System.String,System.Boolean)">
            <summary>
            The message router handles all Trace messages internally and decides what to do with them.  Generally it adds
            trace specific formatting information to the front of the message and then calls the debugging infrastructure
            so that the trace handlers can make the correct calls.  Message router is a fairly heavy routine and should be
            called by all trace routines that follow the standard debug only trace route.
            </summary>
            <param name="messageType">String representation of the type of message</param>
            <param name="theMessage">Textual body of the message</param>
            <param name="moreInfo">Indicates if this message is attached to a previous message</param>
            <param name="addStackInfo">Indicates whether stack and line information should be included</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.ListenerInstalled(System.String)">
            <summary>
            Simple check to see whether a named listener is already installed in the list of chained listeners
            </summary>
            <param name="listnerName">The known name of the listener</param>
            <returns>Boolean indicator - true if installed, false if not</returns>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.ChangeListener(System.String,System.Boolean)">
            <summary>
            When any of the trace listeners are added or removed this routine is used to ensure that only one
            instance of any of the listeners is active at any one time.  At the moment I cannot see why more than
            one listner of the same type would need to be attached.
            </summary>
            <param name="listenerName">The specifc string that referrs to the listner name</param>
            <param name="AddListener">if this is true the listener is added, if its false then the listener is removed</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.GetStackInfoBeforeTraceClass(System.String@,System.String@,System.String@,System.String@)">
            <summary><para>
            Several routines within the trace implementation require that the line and module and method information are
            generated for the statement that they are on.  This routine generates a stack trace from its current location
            then walks back up the trace until it finds the first stack frame that is not related to the trace library.  
            this frame is the frame that the calling code was and this information is then returned in the ref parameters.</para>
            </summary>
            <param name="className">The classname where the code was called from</param>
            <param name="methodName">The method name where the code was called from</param>
            <param name="fileName">The filename containing the code where this was called from</param>
            <param name="lineNumber">The line number that the calling line of code was on relative to the filename</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.GetStackInfoBeforeTraceClass(System.String@,System.String@,System.String@,System.String@,System.String@)">
            <summary><para>
            Several routines within the trace implementation require that the line and module and method information are
            generated for the statement that they are on.  This routine generates a stack trace from its current location
            then walks back up the trace until it finds the first stack frame that is not related to the trace library.  
            this frame is the frame that the calling code was and this information is then returned in the ref parameters.</para>
            </summary>
            <param name="className">The classname where the code was called from</param>
            <param name="methodName">The method name where the code was called from</param>
            <param name="fileName">The filename containing the code where this was called from</param>
            <param name="lineNumber">The line number that the calling line of code was on relative to the filename</param>
            <param name="parameters">The parameter information</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.DumpHashTable(System.Collections.Hashtable)">
            <summary><para>The DumpHashTable function will iterate through all of the elements of a specified hashtable and output
            each fo the elements into the trace stream.  The trace stream will contain a single entry describing the dump operation
            for the hashtable, followed by the contents.</para><para>
            The contents of the hashTable are written as a series of name value pairs, using the ToString() methods of each of the
            key value pairs that have been added to the hash table.  For DumpHashTable to work correctly the debug stream listener
            must support furtherinfo entries in the trace stream.
            </para></summary>
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Info.</para>
            </remarks>
            <param name="ht">A Hashtable to write to the trace stream.</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.DumpObjectLite(System.Object)">
            <summary><para>The DumpObjectLite method will write an object and as many of its fields as it can to the trace stream.
            DumpObjectLite is not recursive and is therefore a relativly lightweight method of writing out the contents of an object
            to the trace stream.</para><para>
            DumpObjectLite will attempt to dump all of the top level members of an object, including static and private members 
            however it is not recursive and will therefore only record the ToString() values of the top level items within an object.
            </para></summary>
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Info.</para>
            </remarks>
            <param name="obj">The object to be explored and written to the trace stream</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.DumpException(System.Exception,System.String,System.String)">
            <Overloads>
            Dump exception will dump out an exception and any inner exceptions as well as a custom message to the
            trace stream.  DumpException is designed to write out customised exception data to allow specific trace stream viewers
            to handle exceptions differently.
            </Overloads>
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Error.</para>
            </remarks>
            <summary>This overload will take the exception and two strings of further information.</summary>
            <param name="ex">The exception to be dumped</param>
            <param name="message">An additional message to send with the exception</param>
            <param name="message2">A further message to be sent as part of the main exception</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.DumpException(System.Exception,System.String)">
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Error.</para>
            </remarks>
            <summary>This overload will take the exception and one strings of further information.</summary>
            <param name="ex">The exception to be dumped</param>
            <param name="message">An additional message to send with the exception</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.DumpException(System.Exception)">
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Info.</para>
            </remarks>
            <summary>This overload will take the exception that is to be written to the trace stream.</summary>
            <param name="ex">Exception to be dumped</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.DumpObjectDeep(System.Object)">
            <summary>
            Conditional defined recursive method to reflect through an object graph and write as much of its 
            contents to the debug stream as possible.  This will call ToString on as many of the internal properties
            of an object and its corresponding object graph as possible.
            This method is only present when the DEBUG contiditional is specified
            </summary>
            <param name="obj">The object that is to be explored and logged to the trace stream</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.DumpStreamAsText(System.IO.Stream,System.Int32)">
            <overloads><para>
            DumpStreamAsText will write out the contents of a stream to the trace log.  DumpStreamAsText will attempt to convert
            the data in a stream to text and then write it out to the debugging log.  If the data in the stream is binary then this
            may cause unpredictable results in the stream listeners.</para><para>
            The position, contents and state of the stream are unnaffected by calling this method.</para>
            </overloads>
            <summary>This overload of DumpStreamAsText will write out up to charsToDump characters to the trace output.</summary>
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Info.</para>
            </remarks>
            <param name="stm">The stream from which to read chars.</param>
            <param name="charsToDump">A limit to the number of characters to wite out to the debugging stream</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.DumpStreamAsText(System.IO.Stream)">
            <summary>This overload of DumpStreamAsText will write out up to 255 characters to the trace stream.</summary>
             <param name="stm">The stream to read.</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.DumpStreamAsHex(System.IO.Stream,System.Int32)">
            <overloads><para>
            DumpStreamAsHex will write out the contents of a stream to the trace log.  DumpStreamAsText will attempt to convert
            the data in a stream to a series of numerical representations of bytes.  These numbers will then be written out to the
            trace log as text.  This is a more reliable method of writing out data that is binary or unknown.</para><para>
            The position, contents and state of the stream are unnaffected by calling this method.</para>
            </overloads>
            <summary>This overload of DumpStreamAsText will write out up to charsToDump characters to the trace output.</summary>
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Info.</para>
            </remarks>
            <param name="stm">The stream from which to read chars.</param>
            <param name="charsToDump">A limit to the number of characters to wite out to the debugging stream</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.DumpStreamAsHex(System.IO.Stream)">
            <summary>
            Overload for the DumpStreamAsHex method to write up to the first 255 characters of the target stream out to the debug log.
            </summary>
            <param name="stm">The stream to dump the first 100 chars of into the debugging stream</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.LiveLog(System.Object,System.String)">
            <overloads>
            <para>The LiveLog method will write a trace entry to the currently attached listeners.  Live Log behaves in a similar way to the Log
            functions, however it is not affected by the DEBUG preprosessing identifiers.</para>
            <para>
            As most Trace listener implementations are single threaded the LiveLog should be used sparingly if at all.
            </para>
            </overloads>
            <summary>An override for LiveLog that takes an object parameter and a further information string.</summary>
            <remarks>
            <para>This method is not conditional on preprosessing identifiers and will therefore remain in release code.</para>
            <para>This method has an Trace level of Error.</para>
            </remarks>
            <param name="theLog">The object that is to be logged.  This objects ToString() method will be called to write to the trace.</param>
            <param name="moreInfo">Any additional information that should be sent to the trace.</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.LiveLog(System.Object)">
            <summary>An override for LiveLog that takes a single object parameter.</summary>
            <remarks>
            <para>This method is not conditional on preprosessing identifiers and will therefore remain in release code.</para>
            <para>This method has a Trace level of Verbose.</para>
            </remarks>
            <param name="theLog">The object that is to be logged.  This objects ToString() method will be called to write to the trace.</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.VerboseLog(System.Object,System.String)">
            <overload><para>
            VerboseLog is a standard logging function that will write its trace output to the trace stream.  The Verbose Log method will
            only write the information to the trace stream if the current trace level is set to verbose.
            If a null parameter is passed to VerboseLog a special "null value passed to log" string will be written to the trace.
            </para></overload>
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Verbose.</para>
            </remarks>
            <param name="theLog">The object that is to be logged.  This objects ToString() method will be called to write to the trace.</param>
            <param name="moreInfo">Any additional information that should be sent to the trace.</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.VerboseLog(System.Object)">
            <param name="theLog">The object that is to be logged.  This objects ToString() method will be called to write to the trace.</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.ResourceGrab(System.String)">
            <summary>
            T::ResourceGrab is used to trace out an entry to indicate that a resource has been allocated by the program.  This can be used
            with the corresponding R::ResourceFree method to trace resource usage.  Each T::ResourceGrab should be accompanied by a T::ResourceFree
            for normal operation of a program.  Use the T::ResourcePoll to check the allocated levels of resources.
            
            Calling T::ResourcePoll at the end of an applications life time will show how many resources were grabbed and not freed
            </summary>
            <param name="resourceName"></param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.ResourceFree(System.String)">
            <summary>
            T::ResourceFree is a pair with T::ResourceGrab to track the usage of resources during the life of a program.
            </summary>
            <param name="resourceName"></param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.ResourcePoll">
            <summary>
            T::ResourcePoll will give you information relating to the current state of resources within the program.
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.TimeStart(System.String)">
            <summary>
            <para> TimeStart is used for rudementary timing of sections of code.  Time start will write a time start identifier to the
            trace stream and start an internal timer.  When TimeStop is called for the same timer title then the value of the elapsed
            time is written to the trace stream.</para><para>
            The TimeStart method relies on a unique timerTitle to be passed to it.  There can only be one active timerTitle of the same
            name at any one time.  Each TimeStart(timerTitle) method call must be matched with a TimeStop(timerTitle) method call to ensure
            that the timing information is writtten to the trace stream.  timerTitles are case sensitive and must be specified exactly.
            </para><para>
            This is not a highly effective or accurate profilling mechanism but will suffice for quick timings.
            </para>
            </summary>   
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Verbose.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown when timerTitle is null or a zero length string.</exception>
            <param name="timerTitle">The unique title for the timer that is being started.</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.TimeStop(System.String)">
            <summary>
            <para> TimeStop will take a corresponding TimeStart entry and record the difference in milliseconds between the TimeStart and
            TimeStop method calls.  The results of this along with the start and stop times will then be written to the debugging stream.</para>
            <para> The TimeStop method requires that it is called with a timerTitle parameter that matches exactly a timerTitle that has
            already been passed to a TimeStart method call. timerTitles are case sensitive and must be specified exactly.
            </para><para>
            This is not a highly effective or accurate profilling mechanism but will suffice for quick timings.
            </para>
            </summary>   
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Verbose.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown when timerTitle is null or a zero length string.</exception>
            <param name="timerTitle">The unique title for the timer that is being started.</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.LogIf(System.Boolean,System.Object)">
            <summary>
            <para>The LogIf method will only write its information to the stream if the first parameter evaluates to true.  This method
            can be used in conjunction with trace switches or custom conditional code.</para>
            </summary>
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Info.</para>
            </remarks>
            <param name="writeLog">Boolean, if this is true the log is written to the trace output.</param>
            <param name="theLog">The object that is to be logged.  This objects ToString() method will be called to write to the trace.</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.LogCo(System.Boolean,System.String,System.String)">
            <summary><para>LogCo is a conditional log method that determines which of its parameters to write to the trace output.  If the first parameter
            is true then the second parameter is written to the trace output.  If the first parameter is false then the third parameter
            is instead written to the trace output.</para>
            <para>The LogCo function works in a similar fasion to the conditional operator, but is used for writing trace information.</para>
            </summary>
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Info.</para>
            </remarks>
            <param name="logFirstValue">The boolean to indicate which fo the other parametrs is written to the stream</param>
            <param name="loggedIfTrue">The parameter to write if the first parameter is true</param>
            <param name="loggedIfFalse">The parameter to write if the first parameter is false</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Log(System.Object)">
            <overloads><para>
            The log function is the basic trace logging function.  It will write the contents of its parameters out to the
            currently active trace streams.  This is the preferred method of writing data to the trace streams.</para>
            <para>If null is passed to this Log override then a special "null value passed to log" entry will be written to the stream</para>
            </overloads>
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Info.</para>
            </remarks>
            <param name="theData">An object whos ToString method will be called to write data to the trace stream.</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Log(System.String)">
            <param name="theMessage">The message to write out to the trace stream</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Log(System.String,System.String)">
            <param name="theMessage">The message to write out to the trace stream</param>
            <param name="moreInfo">Any additional information that should be sent to the trace.</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Write(System.Object)">
            <summary><para>
            The Write and WriteLine statements perform exactly the same basic logging functions as the Log methods.  Write and WriteLine 
            are provided as a more .net friendly interface to the T class, while the Log functions provide backwards compatibility with
            previous non .net versions of Tex trace.</para>
            <para>In order to provide compatibility with the .net behaviour the Write method appends a special DONOTLEAVELINE constant
            to the trace stream which should be respected by viewers and trace listeners.</para>
            <para>If null is passed to this Log override then a special "null value passed to log" entry will be written to the stream</para>
            </summary>
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Info.</para>
            </remarks>
            <param name="theData">An object whos ToString method will be called to write data to the trace stream.</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.WriteLine(System.Object)">
            <summary><para>
            The Write and WriteLine statements perform exactly the same basic logging functions as the Log methods.  Write and WriteLine 
            are provided as a more .net friendly interface to the T class, while the Log functions provide backwards compatibility with
            previous non .net versions of Tex trace.</para>
            <para>In order to provide compatibility with the .net behaviour the Write method appends a special DONOTLEAVELINE constant
            to the trace stream which should be respected by viewers and trace listeners.</para>
            <para>If null is passed to this Log override then a special "null value passed to log" entry will be written to the stream</para>
            </summary>
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Info.</para>
            </remarks>
            <param name="theData">An object whos ToString method will be called to write data to the trace stream.</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.SendViewerCommand(HBOS.FS.Support.Tex.KnownCommands)">
            <overloads><para>
            The Tex trace class is designed to work with viewers that support reading the trace stream.  It is possible to send
            commands directly to the viewers from code using this method.  The known commands can be optionally supported by the
            viewers and can be used to enhance the debugging experience in certain circumstances.</para>
            <para>The Mex viewer currently supports increasing and decreasing indent levels as well as log purges.</para>
            </overloads>
            <summary>This overload uses the KnownCommands enumeration to send predefined commands to the viewer.</summary>
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Error.</para>
            </remarks>
            <param name="kc">The KnownCommands enumeration value to determine which command the viewer should process.</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.SendViewerCommand(System.String)">
            <summary>This overload will send a custom string based command text to the viewer.</summary>
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Error.</para>
            </remarks>
            <param name="commandText">The custom commandText string that should be sent to the viewer.</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.StackToString">
            <summary>
            Primarily an internal function used to generate a stack trace, although available on the public interface for more
            general usage.  This function creates a stack from the current point in code and will remove all LPSTrace related 
            functions from the resulting stack string.  Therefore the data captured is anything in the call stack from above the
            T class related functions
            </summary>
            <returns>String containing the newly created stack information</returns>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.DumpStack(System.String)">
            <summary>
            This will write out the current call stack to the trace stream.
            This method is only present when the DEBUG contiditional is specified
            </summary>
            <param name="theMessage">An additional string to start the dump wtih.</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.AssertIsNull(System.Object,System.String)">
            <summary>
            Performs an assertion to ensure that the first parameter is null.
            </summary>
            <param name="theObj">The object to ensure is null</param>
            <param name="message">A Descriptive reason for failure if the object is not null</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.AssertIsNull(System.Object)">
            <summary>
            Performs an assertion to ensure that the first parameter is null.
            </summary>
            <param name="theObj">The object to ensure is null</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.AssertIsNull(System.Object,System.String,System.String)">
            <summary>
            Performs an assertion to ensure that the first parameter is null.
            </summary>
            <param name="theObj">The object to ensure is null</param>
            <param name="message">A descriptive reason for failure if the object is not null</param>
            <param name="moreInfo">Further information relating to the failure if the object is not null</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.AssertNotNull(System.Object,System.String)">
            <summary>
            Performs an assertion to ensure that the first parameter is not null.
            </summary>
            <param name="theObj">The object to ensure is not null</param>
            <param name="message">A descriptive reason for failure if the object is null</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.AssertNotNull(System.Object)">
            <summary>
            Performs an assertion to ensure that the first parameter is not null.
            </summary>
            <param name="theObj">The object to ensure is not null</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.AssertNotNull(System.Object,System.String,System.String)">
            <summary>
            Performs an assertion to ensure that the first parameter is not null.
            </summary>
            <param name="theObj">The object to ensure is not null</param>
            <param name="message">A descriptive reason for failure if the object is  null</param>
            <param name="moreInfo">Further information relating to the failure if the object is  null</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Assert(System.Boolean,System.String,System.String)">
            <summary>
            An assertion - this assertion is based on the conditional debug.  This is the basic assertion which will be thrown
            if the first parameter is false.
            This method is only present when the DEBUG contiditional is specified
            </summary>
            <param name="blowUpIfFalse">If false the assertion is thrown, otherwise execution continues.</param>
            <param name="message1">The first string for the assertion info</param>
            <param name="message2">The second string for the assertion info</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Assert(System.Boolean,System.String)">
            <summary>
            An assertion overload for one string.
            This method is only present when the DEBUG contiditional is specified
            </summary>
            <param name="blowUpIfFalse">the assertion condition.  If this evaluates to false the assertion will fail.</param>
            <param name="message">A Message to be written to the trace stream if the assertion has failed</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Assert(System.Boolean)">
            <summary>
            An assertion overload with no additional message information being specified.  This assertion overload will generate
            default messages that are written out to the trace stream when the assertion fails.
            This method is only present when the DEBUG contiditional is specified
            </summary>
            <param name="blowUpIfFalse"></param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.AssertE(System.Boolean)">
            <summary>
            AssertE will throw an exception rathern than using the listener to determine the assertion behaviour.  This 
            is especially used for NUnit based unit tests where assertions that present dialog boxes and so on can interupt
            the execution of the application.
            </summary>
            <param name="blowUpIfFalse">The assertion condition.  If this evaluates to false the assertion will fail</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.AssertE(System.Boolean,System.String)">
            <summary>
            AssertE override - assertion that throws an exception rather than letting the listeners take action
            </summary>
            <param name="blowUpIfFalse">The assertion condition.  If this evaluates to false the assertion will fail</param>
            <param name="message">Information to pass relating to the error condition</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.AssertE(System.Boolean,System.String,System.String)">
            <summary>
            AssertE override - assertion that throws an exception rather than letting the listeners take action
            </summary>
            <param name="blowUpIfFalse">The condition</param>
            <param name="message1">Initial information to pass</param>
            <param name="message2">Further information to pass</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.PerformBreach(System.String,System.Reflection.Assembly)">
            <summary>
            A breach condition will throw an assertion in debug code if the breaches first parameter is false.  in 
            release code an exception will be thrown.  While this does allow for assertions to carry into release code
            it should not be used in general for release code.
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Breach(System.Boolean,System.String)">
            <summary>
            A breach condition will throw an assertion in debug code if the breaches first parameter is false.  in 
            release code an exception will be thrown.  While this does allow for assertions to carry into release code
            it should not be used in general for release code.
            </summary>
            <param name="breachedIfFalse">If this parameter is false the Breach will occur</param>
            <param name="message">The message to be displayed indicating the cause of the breach</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.BreachNullParam(System.Object,System.String)">
            <summary>
            This override for breach null param will validate that a parameter passed to it is not null.  IF the parameter
            is null then an assertion will be thrown in DEBUG code and an exception in RELEASE code.  While it is possible
            to leave this method in release code it is not desirable other than as a rapid development aid,.
            </summary>
            <param name="theParam">The parameter to be validated</param>
            <param name="paramName">The descriptive name of the parameter for additional display information</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.BreachNullParam(System.Object)">
            <summary>
            This override for BreachNullParam will check to see whether the supplied parameter is null.  If it is then an
            assertion will be thrown in DBUG code and an exception thrown in RELEASE code.
            While this method does remain present in release code it is unsuitable for proper error handling.  It should be 
            used as a rapid development method only and is in no way a replacement for error handling of parameters.
            </summary>
            <param name="theParam">the parameter that is to be checked for null.</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.BreachNullEmptyStr(System.String)">
            <summary>
             This override for BreachNullEmptyStr is a rapid development method designed to validate parameters to a method
            call in a very fast way.  It will in debug code throw an assertion to indicate that a string parameter passed to it
            was either null or had length 0.  NB This will throw an exception in release code but it is not desirable to use
            this method for release code in general.
            </summary>
            <param name="theParam">The parameter to be validated</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.BreachNullEmptyStr(System.String,System.String)">
            <summary>
            This override for BreachNullEmptyStr is a rapid development method designed to validate parameters to a method
            call in a very fast way.  It will in debug code throw an assertion to indicate that a string parameter passed to it
            was either null or had length 0.  NB This will throw an exception in release code but it is not desirable to use
            this method for release code in general.
            </summary>
            <param name="theParam">The parameter that is to be validated against</param>
            <param name="paramName">The name of the parameter or a description to be part of the error message</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.BreachEnumValue(System.Enum)">
            <summary>
            BreachEnumValue will attempt to verify that an enum contains a value legitimately.  This will check both that it is a 
            legitimate Enum value and also that that value is not Unknown.  It is very important if you have a legitmate value of Unknown 
            for one of your enum values and it is not a reserved word to indicate an invalid value then this function should not be used.
            
            NB Performance note - it is much faster to do this for the specific instance of the enum than to use this generic function.
            </summary>
            <param name="theEnum">The instance of the enum that is to be verified</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.URC">
            <summary>
            URC will throw an assertion to indicate that unreachable code has been found.  This is a shorthand call for
            the unreachable code assertion.  
            
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.NotImplemented(System.String)">
            <summary>
            NotImplemented will write a warning message to the trace stream indicating that the code that has been
            reached has not yet been implemented.  It will then throw an assertion to let the developer know that the
            code that is being executed has not been implemented.  
            </summary>
            <param name="s">An additional string of information to be logged to the trace stream.</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.NotImplemented">
            <summary>
            NotImplemented will write a warning message to the trace stream indicating that the code that has been
            reached has not yet been implemented.  It will then throw an assertion to let the developer know that the
            code that is being executed has not been implemented.  
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Warning">
            <summary>
            The warning function is designed for non fatal warning messages to be written out to the log.  The warning exists
            in live code as well as debug code and will not generate any visible output to the user but will write its statement
            out to the trace handler.  Warnings should not be used as fatal errors, as the error function will provide this.
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Warning(System.String)">
            <summary>
            Override for the warning function.  This will write its output to the trace stream as a warning.  This is not 
            dependant on any preprocessor directives.
            </summary>
            <param name="theMessage">The message to write out as a warning</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Warning(System.String,System.String)">
            <summary>
            OVerride for thew arning function this will write its output to the trace stream as a warning.  This is not dependant
            on any preprocessor directives.
            </summary>
            <param name="theMessage">The message to write out as a warning</param>
            <param name="moreInformation">Further information</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.FurtherInfo(System.String)">
            <summary>
            The further info method is designed to proivide more detailed information relating to the last message that was
            written - listeners that are capable of handling further information will not write it out on the primary display
            but will provide it as additional information to the main event.  It is importnat to note that the main event will
            be the preceding message, no matter what the preceding message was.
            </summary>
            <param name="theMessage">The data of the further information passed to the listener</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.LogELG(System.String)">
            <summary>
            The LogELG function will write directly to the event log, not passing through any of the trace internal structures, while
            this should not be used as a general purpose event logging function it will surfice as a rapid method of writing data to 
            the system event log.
            </summary>
            <param name="theMessage"></param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.LogODS(System.String)">
            <summary>
            LogODS Function will write data directly to the Win32 OutputDebugString debugging API.  While this should not be used
            as a primary method of writing data to the Win32 API it will surfice as a rapid method of calling this function.
            </summary>
            <param name="theMessage"></param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Error(System.String,System.String,System.Exception,System.Boolean,System.Boolean)">
            <summary>
            The error function is not designed to perform fully functional error handling but will suffice as a rapid prototype
            method of writing error data both to the user and to the trace log.  There are a series of parameters that determine 
            which of the outputs are chosen, although in all cases data is written to the trace log.
            </summary>
            <param name="theMessage">the data of the error message</param>
            <param name="moreInformation">Further information relating to the error message</param>
            <param name="ex">The exception that caused the error to occur</param>
            <param name="displayMessagebox">Bool determines whether or not a message box is presented to the user</param>
            <param name="writeEventLogEntry">Bool determines whether or not data is written to the system event log</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Error(System.String,System.String)">
            <summary>
            Override for error fucntion.  This will write an error level string out to the trace function and if the user
            is currently interactive will place a message box on the screen.
            </summary>
            <param name="theMessage">The error message</param>
            <param name="moreInformation">Additional information</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Error(System.String,System.Exception)">
            <summary>
            Override for the error function.  This will write an error level string out to the trace function and if the
            user is currently an interactive user it will place a message box on the screen with the error information.
            </summary>
            <param name="theMessage">The text details of the error message</param>
            <param name="ex">An exception that caused the error to occur</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Error(System.String,System.String,System.Exception)">
            <summary>
            Override for the error function.  This will write an error level string out to the trace function and if the
            user is currently an interactive user it will place a message box on the screen with the error infromation.
            </summary>
            <param name="theMessage">The text description of the error</param>
            <param name="moreInformation">Further text information relating to the error</param>
            <param name="ex">An exception that caused the error to occur</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Error(System.Exception)">
            <summary>
            An override for the Error function.  This will dump the offending exception out to the trace stream and will
            present the user with an error information box if the user is an interactive one.
            </summary>
            <param name="ex">The exception that caused the error to occur</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Error(System.String)">
            <summary>
            Override for error function.  This will write an error level string out to the trace stream and if the user is
            currently interactive will place a message on the screen.
            </summary>
            <param name="theMessage">The error message</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.E">
            <summary>
            The E function describes entry to a block of code or a function.  E will automatically record the name of the function 
            being entered although provides an override that uses a string if this should describe a block.
            This method is only present when the DEBUG contiditional is specified
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.E(System.String)">
            <summary>
            The E override to provide a string will replace the automatically generated method name with the string that you
            provide in the first parameter.
            This method is only present when the DEBUG contiditional is specified
            </summary>
            <param name="theMessage">The name of the block being entered</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.X">
            <summary>
            The X override is the indicator for leaving a block that has been entered with E.
            This method is only present when the DEBUG contiditional is specified
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.X(System.String)">
            <summary>
            The X override is the indicator for leaving a block that has been entered with E.
            This method is only present when the DEBUG contiditional is specified
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T._E(System.String,System.String)">
            <summary>
            The _E function is a method of orverriding the E default behaviour of specifying the method name as the
            entry point to a block of code.  With _E you can specify a block name, however the corresponding _X function
            should be used to indicate the end of the block with the same string passed.
            This method is only present when the DEBUG contiditional is specified
            </summary>
            <param name="subRoutineName">The name of the block to enter</param>
            <param name="theMessage">The textual message to enter with</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T._X(System.String,System.String)">
            <summary>
            The _X method is an override for the X function that allowes the specification of the name of the exit block
            wtihout allowing it to look up the name of the method to identify the block.  This should only be used in
            conjunction with the _E function.
            This method is only present when the DEBUG contiditional is specified
            </summary>
            <param name="subRoutineName">The name of the block or routine previously _Ed</param>
            <param name="theMessage">The message to write</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.GetCurrentThreadInformation">
            <summary>
            The GetCurrentThreadInformation method will return a string with information about the currently executing thread
            including the .net thread name, whether or not it is pooled and the underlying operating system thread id.
            </summary>
            <returns>String in the format Net Thread: NAME (pooled)||(notpooled) OS Thread: THREADID</returns>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.GetMethodNameAboveMe">
            <summary><para>
            GetMethodNameAboveMe will return the Name of the method that is immediately above your method in the call stack.  This will
            therefore be the full name of the method that called you. </para>
            <para>
            For Example:
            Main      « Call Get method name here ... returns null
              Method1  « Call Get method name here ... returns Main
                Method2  « Call Get method name here ... returns Method1</para>
            <remarks>If there are no methods above you in the call stack this method will return null</remarks>
            </summary>
            <returns>Returns the name of the method that called the method calling this method.  If no such method exists returns null.</returns>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.#cctor">
            <summary>
            The static constructor will removethe existing default .net listener and put in place the default Tex listener.  It is important to
            note that this occurs as if trace is enabled from a configuration file then the alternative listeners there will cause the
            tex default listener to be inserted here with this method.
            </summary>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Initialise">
            <overloads><para>
            Initialise can be used to write out default information to the tracing stream.  The Initialise method is not required for tracing
            but helps the viewers present more usefull debugging information.</para><para>
            It is highly recommended that the Initialise method is called once for the lifetime of the application, before other trace information
            has been written to the stream.
            </para>  
            </overloads>
            <summary>The default initialise will write out default information and assumes that the default listener is used.</summary>
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Error.</para>
            </remarks>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Initialise(System.Diagnostics.TraceLevel)">
            <summary><para>This override for Initialise will set the TraceLevel to a specific level before calling the default Initialise.</para></summary>
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Error.</para>
            </remarks>
            <param name="tl">The desired trace level from the System.Diagnostics.TraceLevel enumeration</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Initialise(System.String,System.String,System.String,System.String)">
            <summary><para>This override for the Initialise method will allow you to specify all of the information that the Initialise method
            normally works out for itself.  This Initialise method should only be used if there is either a permissions or other problem related
            to getting the information from the system.</para><para>
            If you use this override you must specify values for each of the parameters, all of the other initialise overrides provide shortcuts
            to this Initialise and default the various parameters.
            </para></summary>
            <remarks>
            <para>This method is dependant on the DEBUG preprosessing identifier.</para>
            <para>This method has a Trace level of Error.</para>
            </remarks>
            <exception cref="T:System.ArgumentNullException">Thrown if any of the parameters are passed as null.</exception>
            <param name="processName">The friendly name for the process</param>
            <param name="machineName">The name of the machine that it runs on</param>
            <param name="mainModule">The filename of the main module</param>
            <param name="windowTitle">The title of the window if any</param>
        </member>
        <member name="M:HBOS.FS.Support.Tex.T.Initialise(System.String)">
            <summary>
            This initialise override will direct the trace output to a file Listener, removing the default listener.  This is the simplest way to direct
            all of the trace output to a file, although it is not the only way.
            </summary>
            <param name="filename">If the filename is specified then the trace output will be directed to this file.</param>
        </member>
        <member name="P:HBOS.FS.Support.Tex.T.OutputFilename">
            <summary><para>
            This property gets or sets the filename that the trace output is to be written to if the file based trace listener is being
            used.  
            </para>
            <remarks>Changes take effect from when the property is set and no attempt is made to place previous traces to the new filename
            This property has no effect if the filelistener is not being used.</remarks>
            </summary>
        </member>
        <member name="P:HBOS.FS.Support.Tex.T.CurrentTraceLevel">
            <summary>
            Set the current level for tracing - this will use the TraceLevel enum to determine which of the logging functions
            will write data out.  The order of increasing data is off, error, warning, info, verbose.
            </summary>
        </member>
        <member name="P:HBOS.FS.Support.Tex.T.DefaultListenerActive">
            <summary>
            Determine whether the default TEX listener is used - this is designed for development time routing to the MEX viewer
            and should be used for development.  This should not really be used for large volumes or live tracing - the default
            file listener should be used for this.
            </summary>
        </member>
        <member name="P:HBOS.FS.Support.Tex.T.FileListenerActive">
            <summary>
            Will add or remove the file listener.  For 2002 this is the in build listener for VS 2003 this is the .net frameworks
            own file listener
            </summary>
        </member>
        <member name="P:HBOS.FS.Support.Tex.T.ODSListenerActive">
            <summary>
            Determine whether the ODS listener is installed.  This will send all of the output via the Win32 output debug
            string call but will not prepend any of the TEX specific data and can therefore be more suitably used with viewers
            such as DebugView.
            </summary>
        </member>
        <member name="P:HBOS.FS.Support.Tex.T.ConsoleListenerActive">
            <summary>
            Add or remove the console listener to the collection of listeners that are filtering data.  This implementation is a non
            thread safe console implementation
            </summary>
        </member>
        <member name="P:HBOS.FS.Support.Tex.T.OriginalListenerActive">
            <summary>
            Add or remove the original trace listener to the collection of listeners that are filtering data.  The original listener
            is the default listener that is provided with .net 2003.
            </summary>
        </member>
        <member name="P:HBOS.FS.Support.Tex.T.AddStackInformation">
            <summary>
            Decide whether generically stack information is added to the strings that are written out to the trace listener streams
            if this is set to false then most messages will not append stack information.
            </summary>
        </member>
        <member name="E:HBOS.FS.Support.Tex.T.CustomTagReplacer">
            <summary>
            This event allows a user to hook the trace stream and replace custom tags in the strings.  Tags normally
            take the form %%TAGNAME%% and there are existing tags such as time strings.  Custom tags can be used but should be 
            done so with care in order that trace data is not overwritten.
            </summary>
        </member>
        <member name="T:HBOS.FS.Support.Tex.T.TraceCustomEventHandler">
            <summary>
            This delegate is designed to allow users to hook the trace streams.  It is used in the events.  
            </summary>
        </member>
    </members>
</doc>
