using System;
using HBOS.FS.AMP.UPD.Types.FundGroups;
using HBOS.FS.AMP.UPD.Types.Funds;
using HBOS.FS.AMP.UPD.Types.WeightedIndices;

namespace HBOS.FS.AMP.UPD.Types.AssetFunds
{
    /// <summary>
    /// The asset fund holding a collection of funds.
    /// </summary>
    public abstract class AssetFund : EntityBase
    {
        #region Member variables
        
        //
        // Note. As we work through the drop II use cases move the member
        //       variables that we still need in this class into this 
        //       region so what is left we know we can remove from the class.
        //
        #region Drop II 
        private string m_assetFundCode;				//Readonly (from db)
        private string m_shortName;                 //(from db)
        private string m_fullName;                  //(from db)

        private decimal m_AMTolerance;				//(from db)
		private decimal m_authorisedUnitPrice;		
		private bool m_authorisedUnitPriceSet;		

		//Allow a null collection - as fund group persister returns a collection, calling client will
		//mostly just set the fund collection on the fund.
		private FundGroupCollection m_fundGroups = null;

        #region Objects
/*
        private FundCollection m_funds = new FundCollection();
*/
        private WeightedMovementCollection m_weightedMovements = null; //create on a get only so we don't create then throw away 
        #endregion

        #endregion

        #region Drop I
		private string m_companyCode; 				//Readonly (from db)
		private decimal m_unitPrice;				//Readonly (from db)
		private decimal m_unitPriceMovement; 		//Readonly (from db)
		private decimal m_predictedAssetMovement;	//Readonly
		private decimal m_previousUnitPrice;        //Readonly (from db)
		private decimal m_AMVariance;				//Readonly

		//m_withinAMTolerance is set by checkTolerance which is called by the constructor
		//so does not need to be passed in as a param to the constructor.
		//Note: as long as AMTolerance column exists in db table then AMTolerance set
		//will be true, and checkTolereance will set m_withinAMTolerance
		private bool m_withinAMTolerance;           //Readonly 

		private DateTime m_valuationPoint;			//Readonly
		private bool m_lockedForCalculation;        // (from db)
		private decimal m_predictedUnitPrice;

		//Indicators
		private bool m_unitPriceSet;		 	    //Readonly
		private bool m_previousUnitPriceSet;        //Readonly
		private bool m_unitPriceMovementSet;		//Readonly
		private bool m_predictedAMSet;
		private bool m_AMVarianceSet;
		private bool m_predictedUnitPriceSet;
		private bool m_AMToleranceSet;				//Readonly
		private bool m_valuationPointSet;			//Readonly

		#region objects

		// TODO: Remove when asset fund object type complete
        //to be replaced with single coll: WeightedMovementCollection
		private AssetFundIndexWeightedCollection m_marketValueSplits;
		private AssetFundIndexWeightedCollection m_weightedIndices;
		private HBOS.FS.AMP.UPD.Types.Currency.Currency currency;
    	private HBOS.FS.AMP.UPD.Types.AssetFunds.AssetMovementConsitituentCollection assetMovementConstitute;

    	#endregion

        #endregion

        #endregion

		#region New Constructors

		/// <summary>
		/// Constructor to be used when you create a new Asset Fund
		/// </summary>
		protected AssetFund()
		{
			this.m_assetFundCode = "";
			this.m_shortName = "";
			this.m_fullName = "";
			this.m_companyCode = "";
			this.m_unitPrice = 0;
			this.m_unitPriceMovement = 0;
			this.m_previousUnitPrice = 0;
			this.m_previousUnitPriceSet = false;
			this.m_predictedAssetMovement = 0;
			this.m_AMVariance = 0;
			this.m_AMTolerance = 0;
			this.m_withinAMTolerance = false;
			this.m_valuationPoint = DateTime.Now;
			this.m_unitPriceSet = false;
			this.m_unitPriceMovementSet = false;
			this.m_AMToleranceSet = false;
			this.m_valuationPointSet = false;
			this.m_lockedForCalculation = false;
			this.m_predictedUnitPrice = 0;
			this.m_predictedUnitPriceSet = false;

			this.m_authorisedUnitPrice = 0M;
			this.m_authorisedUnitPriceSet = false;
			
			//objects
			m_marketValueSplits = new AssetFundIndexWeightedCollection();
			m_weightedIndices = new AssetFundIndexWeightedCollection();	

			//don't create here, as most likely this will get overwritten straight away with a collection set.
			//m_weightedMovements = new WeightedMovementCollection();

			m_fundGroups = new FundGroupCollection();		//KAJ 13/05/05

			//Set up IEntityBase members
			m_isNew = true;
			m_isDeleted = false;
			m_timestamp = new byte[1];
			m_isDirty = true;
		}

		/// <summary>
		/// Constructor to be used when you create an existing Asset Fund
        /// </summary>
        /// <param name="assetFundCode"></param>
        /// <param name="shortName"></param>
        /// <param name="fullName"></param>
        /// <param name="companyCode"></param>
        /// <param name="unitPrice"></param>
        /// <param name="valuationPoint"></param>
        /// <param name="unitPriceMovement"></param>
        /// <param name="previousUnitPrice"></param>
        /// <param name="previousUnitPriceSet"></param>
        /// <param name="authorisedUnitPrice"></param>
        /// <param name="authorisedUnitPriceSet"></param>
        /// <param name="lockedForCalculation"></param>
        /// <param name="AMTolerance"></param>
        /// <param name="marketValueSplits"></param>
        /// <param name="weightedIndices"></param>
        /// <param name="unitPriceSet"></param>
        /// <param name="unitPriceMovementSet"></param>
        /// <param name="AMToleranceSet"></param>
        /// <param name="valuationPointSet"></param>
        /// <param name="timeStamp"></param>
        /// <param name="assetFundStatus"></param>
        /// <param name="weightedMovements"></param>
		protected AssetFund(string assetFundCode, string shortName, string fullName, string companyCode
            , decimal unitPrice, DateTime valuationPoint, decimal unitPriceMovement
            , decimal previousUnitPrice, bool previousUnitPriceSet
			, decimal authorisedUnitPrice, bool authorisedUnitPriceSet
			, bool lockedForCalculation
			, decimal AMTolerance
			, AssetFundIndexWeightedCollection marketValueSplits
			, AssetFundIndexWeightedCollection weightedIndices
			, bool unitPriceSet, bool unitPriceMovementSet, bool AMToleranceSet, bool valuationPointSet
			, byte[] timeStamp, int assetFundStatus, WeightedMovementCollection weightedMovements)
		{
			//TODO - assetFundStatus not being used!

			this.assetMovementConstitute=null;
			this.currency=null;//new Currency.Currency();
			this.m_assetFundCode = assetFundCode;
			this.m_shortName = shortName;
			this.m_fullName = fullName;
			this.m_companyCode = companyCode;
			this.m_unitPrice = unitPrice;
			this.m_unitPriceMovement = unitPriceMovement;
			this.m_previousUnitPrice = previousUnitPrice;
			this.m_previousUnitPriceSet = previousUnitPriceSet;
			this.m_AMTolerance = AMTolerance;
			this.m_valuationPoint = valuationPoint;
			this.m_unitPriceSet = unitPriceSet;
			this.m_unitPriceMovementSet = unitPriceMovementSet;
			this.m_AMToleranceSet = AMToleranceSet;
			this.m_valuationPointSet = valuationPointSet;
			this.m_lockedForCalculation = lockedForCalculation;

			this.m_predictedUnitPrice = 0;
			this.m_predictedUnitPriceSet = false;
			this.m_predictedAssetMovement = 0;
			this.m_predictedAMSet = false;

			//objects
			//todo these two to be removed
			m_marketValueSplits = marketValueSplits;
			m_weightedIndices = weightedIndices;			

            // SB - new version
            m_weightedMovements = weightedMovements;
			
			//allow fundgroups to be null so that user can set them without creating one unnecessarily
			//(persisters return a FundGroupCollection which can be set directly as a property here)
			//m_fundGroups = new FundGroupCollection();		//KAJ 13/05/05

			//Set up IEntityBase members
			m_isNew = false;
			m_isDeleted = false;
			m_timestamp = timeStamp;
			m_isDirty = false;

			//Do the rest of the calculations
			checkTolerance();
		}

		/// <summary>
		/// Initialises the asset fund with data for light use only (eg static data)
		/// </summary>
		/// <param name="assetFundCode">The HiPortfolio fund code.</param>
		/// <param name="shortName">The short name of the asset fund</param>
		/// <param name="fullName">The full name of the asset fund</param>
		/// <param name="companyCode"></param>
		/// <param name="lastUpdatedTimeStamp">The database timestamp used for concurrency checking</param>
		/// <param name="fundGroups">The collection of fund groups associated with this asset fund</param>
		/// <param name="weightedMovements">The collection of weighted movements associated with this asset fund</param>
		protected AssetFund(string assetFundCode, string shortName, string fullName, string companyCode, byte[] lastUpdatedTimeStamp, FundGroupCollection fundGroups,WeightedMovementCollection weightedMovements)
		{
			this.m_assetFundCode = assetFundCode;
			this.m_shortName = shortName;
			this.m_fullName = fullName;
			this.m_companyCode = companyCode;
			this.m_timestamp = lastUpdatedTimeStamp;
			this.m_fundGroups = fundGroups;
			this.m_weightedMovements = weightedMovements;

			//Set up IEntityBase members
			m_isNew = false;
			m_isDeleted = false;
			m_isDirty = false;
		}

		/// <summary>
		/// Initialises the asset fund with data for static export use only
		/// </summary>
		/// <param name="assetFundCode">The HiPortfolio fund code.</param>
		/// <param name="shortName">The short name of the asset fund</param>
		/// <param name="fullName">The full name of the asset fund</param>
		/// <param name="companyCode">The company code for this asset fund</param>
		/// <param name="assetMovementTolerance">am tolerance derived from child funds</param>
		/// <param name="fundGroups">The collection of fund groups associated with this asset fund</param>
		/// <param name="weightedMovements">The collection of weighted movements associated with this asset fund</param>
		protected AssetFund(string assetFundCode, string shortName, string fullName, string companyCode, decimal assetMovementTolerance, FundGroupCollection fundGroups, WeightedMovementCollection weightedMovements)
		{
			this.m_assetFundCode = assetFundCode;
			this.m_shortName = shortName;
			this.m_fullName = fullName;
			this.m_companyCode = companyCode;
			this.m_AMTolerance = assetMovementTolerance;
			this.m_AMToleranceSet = true; //is always true - even if coalesce returns a 0 - see Kevin.todo - lose this variable!
			this.m_fundGroups = fundGroups;
			this.m_weightedMovements = weightedMovements;

			//Set up IEntityBase members
			m_isNew = false;
			m_isDeleted = false;
			m_isDirty = false;
		}

		#endregion

        #region Properties

		/// <summary>
		/// The collection of AssetFundGroup that detail the fund groups that this asset fund is linked to.
		/// This collection shall always exist and shall return an empty collection if the fund is not associated
		/// with any fund groups.
		/// </summary>
		public FundGroupCollection FundGroups
		{
			get
			{
				if (m_fundGroups == null)
				{
					m_fundGroups = new FundGroupCollection();
				}
				return m_fundGroups;
			}
			set
			{
				m_fundGroups = value;
			}
		}

		/// <summary>
		/// A string representation of the type used for display and reporting purposes.
		/// This is just to make life easier for xslt etc
		/// todo - can we remove display properties from the entity?
		/// </summary>
		public abstract string AssetFundType
		{
			get;
			//todo - do we need a set for the grid?
		}
        /// <summary>
        /// The unique identifier for the asset fund.
        /// </summary>
        public string AssetFundCode
        {
            get
            {
				return this.m_assetFundCode;
			}

			
			set
			{
				this.m_assetFundCode = value;
			}
        }

        /// <summary>
        /// The short asset fund name.
        /// </summary>
        public string ShortName
        {
			get
			{
				return this.m_shortName;
			}

			set
			{
				this.m_shortName = value;
                SetDirtyFlag();
            }
        }

        /// <summary>
        /// The full asset fund name.
        /// </summary>
        public string FullName
        {
			get
			{
				return this.m_fullName;
			}

			set
			{
				this.m_fullName = value;
				SetDirtyFlag();
			}
        }

		/// <summary>
		/// A code that represents the Company that this Asset Fund belongs to
		/// </summary>
		public string CompanyCode
		{
			get
			{
				return this.m_companyCode;
			}

			
			set
			{
				this.m_companyCode = value;
			}
		}

		/// <summary>
		/// Today's price of the Asset Fund
		/// </summary>
		public decimal UnitPrice
		{
			get
			{
				return this.m_unitPrice;
			}

			
			set
			{
				this.m_unitPrice = value;
			}
		}

		/// <summary>
		/// Whether the Current price has been set for this asset fund
		/// </summary>
		public bool UnitPriceSet
		{
			get	
			{
				return this.m_unitPriceSet;
			}

			
			set
			{
				this.m_unitPriceSet = value;
			}
		}

		/// <summary>
		/// Today's authorised price of the Asset Fund
		/// </summary>
		public decimal AuthorisedUnitPrice
		{
			get
			{
				return this.m_authorisedUnitPrice;
			}

			
			set
			{
				this.m_authorisedUnitPrice = value;
			}
		}

		/// <summary>
		/// Whether the Current authorised price has been set for this asset fund
		/// </summary>
		public bool AuthorisedUnitPriceSet
		{
			get	
			{
				return this.m_authorisedUnitPriceSet;
			}

			
			set
			{
				this.m_authorisedUnitPriceSet = value;
			}
		}

		/// <summary>
		/// The proportional movement in the price from previous to current
		/// </summary>
		public decimal UnitPriceMovement
		{
			get
			{
				return this.m_unitPriceMovement;
			}

			
			set
			{
				this.m_unitPriceMovement = value;
			}
		}

		/// <summary>
		/// Whether the AM has been set for this asset fund
		/// </summary>
		public bool UnitPriceMovementSet
		{
			get	
			{
				return this.m_unitPriceMovementSet;
			}

			
			set
			{
				this.m_unitPriceMovementSet = value;
			}
		}


		/// <summary>
		/// A calculated predicted unit price to use when the actual unit price is not available.
		/// </summary>
		public decimal PredictedUnitPrice
		{
			get
			{
				return this.m_predictedUnitPrice;
			}

			
			set
			{
				this.m_predictedUnitPrice = value;
			}
		}

		/// <summary>
		/// Flag indicating that the PredictedUnitPrice is a valid value.
		/// </summary>
		public bool PredictedUnitPriceSet
		{
			get
			{
				return this.m_predictedUnitPriceSet;
			}

			
			set
			{
				this.m_predictedUnitPriceSet = value;
			}
		}

		/// <summary>
		/// The predicted Asset Movement for this Asset Fund (derived from Market Value splits)
		/// </summary>
		public decimal PredictedAssetMovement
		{
			get
			{
				return this.m_predictedAssetMovement;
			}

			
			set
			{
				this.m_predictedAssetMovement = value;
			}
		}

		/// <summary>
		/// Shows whether the Predicted Asset Movement has been set for this Asset Fund
		/// </summary>
		public bool PredictedAssetMovementSet
		{
			get
			{
				return m_predictedAMSet;
			}
			
			set
			{
				m_predictedAMSet = value;
			}
		}
	

		/// <summary>
		/// The previous authorised asset unit price.
		/// </summary>
		public decimal PreviousUnitPrice
		{
			get
			{
				return this.m_previousUnitPrice;
			}

			
			set
			{
				this.m_previousUnitPrice = value;
			}
		}

		/// <summary>
		/// Flag inidcating whether the PreviousUnitPrice is a valid value or not.
		/// </summary>
		public bool PreviousUnitPriceSet
		{
			get
			{
				return this.m_previousUnitPriceSet;
			}

			
			set
			{
				this.m_previousUnitPriceSet = value;
			}
		}

		/// <summary>
		/// The difference between Price movement and Predicted Asset Movement
		/// </summary>
		public decimal AssetMovementVariance
		{
			get
			{
				return this.m_AMVariance;
			}
			
			set
			{
				this.m_AMVariance = value;
			}
		}

		/// <summary>
		/// Whether the difference between Price movement and Predicted Asset Movement has been set
		/// </summary>
		public bool AssetMovementVarianceSet
		{
			get
			{
				return this.m_AMVarianceSet;
			}

			
			set
			{
				this.m_AMVarianceSet = value;
			}
		}

		/// <summary>
		/// The tolerance level set for this asset fund
		/// </summary>
		public decimal AssetMovementTolerance
		{
			get
			{
				return this.m_AMTolerance;
			}

			
			set
			{
				this.m_AMTolerance = value;
			}
		}

		/// <summary>
		/// The tolerance level set for this asset fund as a percentage 
		/// </summary>
		public decimal AssetMovementTolerancePercentage
		{
			get
			{
				return this.m_AMTolerance * 100;
			}

			
			set
			{
				this.m_AMTolerance = value / 100;
			}
		}

		/// <summary>
		/// Whether the AM Tolerance has been set for this asset fund
		/// </summary>
		public bool AssetMovementToleranceSet
		{
			get	
			{
				return this.m_AMToleranceSet;
			}

			
			set
			{
				this.m_AMToleranceSet = value;
			}
		}

		/// <summary>
		/// Whether the Predicted AM movement - Price movement is greater than the tolerance
		/// </summary>
		public bool WithinAssetMovementTolerance
		{
			get
			{
				return this.m_withinAMTolerance;
			}

			
			set
			{
				this.m_withinAMTolerance = value;
			}
		}
	
		/// <summary>
		/// This property is here for displaying in the Current Asset Fund Status grid 
		/// </summary>
		public string WithinAssetMovementToleranceDisplay
		{
			get
			{
				if (m_withinAMTolerance) 
				{
					return "Y";
				}
				else
				{
					return "N";
				}
			}
		}

		/// <summary>
		/// The latest valuation point for this asset fund
		/// </summary>
		public DateTime ValuationPoint
		{
			get
			{
				return this.m_valuationPoint;
			}

			
			set
			{
				this.m_valuationPoint = value;
			}

		}

		/// <summary>
		/// Whether the Valuation Point has been set for this asset fund
		/// </summary>
		public bool ValuationPointSet
		{
			get
			{
				return this.m_valuationPointSet;
			}

			
			set
			{
				this.m_valuationPointSet = value;
			}
		}

		/// <summary>
		/// True if any one fund for the asset fund has a current authorised price.  This means the
		/// imported data at the time of authorisation is used rather than the latest (in the case of
		/// reimports).
		/// </summary>
		public bool LockedForCalculation
		{
			get
			{
				return this.m_lockedForCalculation;
			}

			
			set
			{
				this.m_lockedForCalculation = value;
			}
		}

        /// <summary>
        /// The market value splits for this Asset Fund (used for configuration only)
		/// Todo - remove
		/// </summary>
		public AssetFundIndexWeightedCollection MarketValueSplits
        {
            get
            {
				return this.m_marketValueSplits;
			}

            set
            {
				this.m_marketValueSplits = value;
			}
        }

		/// <summary>
		/// Returns the collection of movements (IWeightedMovement) which details the following:
		///		For Linked Asset Funds or OEIC Asset Funds: 
		///			the currency, market and country codes along with how the currencies and markets have moved in 1 day.
		///		For Composite Asset Funds:
		///			the Linked Fund Code and its movement
		///		(and proportion for both)
		/// </summary>
		/// <returns></returns>
		public WeightedMovementCollection WeightedMovements
		{
			get
			{
				//only create one if we need to!
				if (m_weightedMovements == null)
				{
					m_weightedMovements = new WeightedMovementCollection();
				}
				return m_weightedMovements;
			}

			// todo - vh - do we need this set for the grid? Thought it was just for properties on the collection,
			// not the collection itself
			set
			{
				this.m_weightedMovements = value;
                checkTolerance();
			}
		}

		/// <summary>
		/// The market value splits for this Asset Fund (used for calculations only)
		/// Todo - remove
		/// </summary>
		public AssetFundIndexWeightedCollection MarketIndexMovements
		{
			get
			{
				return m_weightedIndices;
			}

			
			set
			{
				this.m_weightedIndices = value;
			}
		}


		#endregion

		#region Display Properties (re-introduced due to grid limitations. TODO - try to resolve and bring back property formatter)

		/// <summary>
		/// Read only property that returns the AssetMovementTolerance Display string
		/// </summary>
		public string AssetMovementToleranceDisplay
		{
			get
			{
				return DisplayFormat.Percent(AssetMovementTolerance, AssetMovementToleranceSet);
			}
		}

		/// <summary>
		/// as above but displays 0 as opposed to unavailable
		/// </summary>
		public string AssetMovementToleranceDisplay2
		{
			get
			{
				return DisplayFormat.Percent(AssetMovementTolerance, true);
			}
		}

		/// <summary>
		/// Read only property that returns the Unit Price Display string
		/// </summary>
		public string UnitPriceDisplay
		{
			get
			{
				return DisplayFormat.Decimal(UnitPrice, UnitPriceSet);
			}
		}

		/// <summary>
		/// Read only property that returns the Unit Price Movement Display string
		/// </summary>
		public string UnitPriceMovementDisplay
		{
			get
			{
				return DisplayFormat.Percent(UnitPriceMovement, UnitPriceMovementSet);
			}
		}

		/// <summary>
		/// Read only property that returns the Predicted Asset Movement Display string
		/// </summary>
		public virtual string PredictedAssetMovementDisplay
		{
			get
			{
				return DisplayFormat.Percent(PredictedAssetMovement, PredictedAssetMovementSet);
			}
		}

		/// <summary>
		/// Read only property that returns the Asset Movement Variance Display string
		/// </summary>
		public string AssetMovementVarianceDisplay
		{
			get
			{
				return DisplayFormat.Percent(AssetMovementVariance, AssetMovementVarianceSet);
			}
		}

		#endregion

   
		#region Methods

		/// <summary>
		/// Perform the calculations necessary to check whether the asset movement is within the
		/// allowed tolerance or not.
		/// </summary>
		private void checkTolerance()
		{
			try
			{
				this.m_predictedUnitPrice = 0;
				this.m_predictedUnitPriceSet = false;
				this.m_predictedAMSet = false;
				this.m_AMVarianceSet = false;

				//Calculate Predicted AM
				if (this.predictAssetMovement())
				{
					if (this.UnitPriceMovementSet)
					{
						//Set the Asset Movement variance (actual price movement - predicted asset movement)
						this.m_AMVariance = this.UnitPriceMovement - this.PredictedAssetMovement;
						this.m_AMVarianceSet = true;

						//Check tolerance
						if (this.AssetMovementToleranceSet)
						{
							//Check the tolerance and set the Tolerance flag
							this.m_withinAMTolerance 
								= (Math.Abs(this.AssetMovementVariance) <= this.AssetMovementTolerance);
						}
					}

					if (this.PreviousUnitPriceSet)
					{
						// Calculated the predicted unit price.
						this.m_predictedUnitPrice 
							= this.PreviousUnitPrice + (this.PreviousUnitPrice * this.PredictedAssetMovement);
						this.m_predictedUnitPriceSet = true;
					}
				}
			}
			catch (Exception e)
			{
				throw new Exception(e.Message);
			}
		}

		/// <summary>
		/// Calculate the predicted asset movement.
		/// </summary>
		private bool predictAssetMovement()
		{
			bool result = false;
			decimal assetMovement = 0;
			
            // NB - (SB): There is no way of getting the proportion from the 
            // IWeightedMovement interface, so this checking has been removed
            // decimal totalWeightings = 0;

			// Ignore asset funds without any index weightings.
			if (this.WeightedMovements == null || this.WeightedMovements.Count == 0)
			{
				return result;
			}

			//Step through all the Weighted indexes and predict the total asset movement
			for (int count = 0; count < this.WeightedMovements.Count; count++)
			{
				
				IWeightedMovement index = this.WeightedMovements[count];

				if (index != null)
				{
                    assetMovement += index.CalculateMovement();
				}
			}

			//Set the Predicted Asset Movement
			this.m_predictedAssetMovement = assetMovement;
			this.m_predictedAMSet = true;

			result = true;

			return (result);
		}

		#endregion

        #region Public Methods

        /// <summary>
        /// Indicates whether the asset fund is locked. 
        /// Checks child fund is authorised for this.
        /// </summary>
        /// <param name="assetFundChildFunds"></param>
        /// <returns></returns>
        public  static bool IsLocked(FundCollection assetFundChildFunds)
        {
            //TODO - should the assetChildFunds actually be made a member? 
            bool isLocked = false;
            if (assetFundChildFunds == null)
            {
                throw new NullReferenceException ("funds collection is null");
            }

            for (int i = 0; i < assetFundChildFunds.Count; i++)
            {
                Fund childFund = assetFundChildFunds[i];
                if (childFund.IsAuthorised)
                {
                    isLocked = true;
                    break;
                }
            }
				
            return isLocked;
        }

		/// <summary>
		/// Accepts a collection of movements following an update (by UI). 
		/// This clears the importId and updates local collection with the changed collection.
		/// Note that composites cannot be updated so an exception is thrown if 
		/// a collection of composite weightings is passed in
		/// </summary>
		/// <param name="updatedMovements"></param>
		public void UpdateWeightedMovements(WeightedMovementCollection updatedMovements)
		{
			//business logic so is here, not in UI

			//what we have to do is clear the existing collection of all movements,
			//then copy these movements in, and set importID to 0 to indicate that
			//we need to generate a new ImportID

			if (m_weightedIndices == null)
			{
				m_weightedMovements = new WeightedMovementCollection();
			}
			else
			{
				m_weightedMovements.Clear();
			}
			for (int i = 0; i < updatedMovements.Count; i++)
			{
				if (updatedMovements[i] is WeightedIndex)
				{
					((WeightedIndex) updatedMovements[i]).ImportID = 0;
					((WeightedIndex) updatedMovements[i]).AssetFundCode = m_assetFundCode;
				}
				else
				{
					//currently not possible to update Composite Weightings
					throw new ArgumentException ("Unexpected type in weighted movements collection");
				}
				m_weightedMovements.Add(updatedMovements[i]);
			}
			SetDirtyFlag();
		}

		/// <summary>
		/// Gets the currency.
		/// </summary>
		/// <value></value>
    	public object Currency
    	{
    		get
    		{
				return currency;
    		}
    	}

		/// <summary>
		/// Gets the asset movement constitute collection containing all the weighted benchmarks.
		/// </summary>
		/// <value></value>
    	public object AssetMovementConstitute
    	{
    		get { return assetMovementConstitute; }
    	}

    	#endregion


	}
}
