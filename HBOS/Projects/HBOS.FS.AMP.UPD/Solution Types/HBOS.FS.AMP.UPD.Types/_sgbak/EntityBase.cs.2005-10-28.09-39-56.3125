using System;
using System.Collections;
using System.Reflection;
using HBOS.FS.AMP.Entities;

namespace HBOS.FS.AMP.UPD.Types
{
	/// <summary>
	/// 
	/// </summary>
	[Serializable]
	public class EntityBase : IEntityBase
	{
		/// <summary>
		/// Dirt flag
		/// </summary>
		protected bool m_isDirty;
		/// <summary>
		/// New Flag
		/// </summary>
		protected bool m_isNew = true; //existing UPD 2.0 always initially sets to true, so set to false in ctor used by persister
		/// <summary>
		/// 
		/// </summary>
		protected bool m_isDeleted;
		/// <summary>
		/// 
		/// </summary>
		protected byte[] m_timestamp;

		/// <summary>
		/// Set the modified flag to be true
		/// </summary>
		protected void SetDirtyFlag()
		{
			//
			// TODO: Possibly check for initial loading and populating code here
			//
			this.m_isDirty = true;
		}

		/// <summary>
		/// Returns true if the object needs to be updated in the database.
		/// Otherwise false.
		/// </summary>
		public virtual bool IsDirty
		{
			get
			{
				return m_isDirty;
			}
			set
			{
				m_isDirty = value;
			}
		}

		/// <summary>
		/// Returns true if the object is a newly created object being added to the database.
		/// </summary>
		public bool IsNew
		{
			get
			{
				return m_isNew;
			}

			set
			{
				m_isNew = value;
			}
		}

		/// <summary>
		/// Returns true if the object has been flagged as deleted.  Set to false if the
		/// data has been un-deleted
		/// </summary>
		public bool IsDeleted
		{
			get 
			{
				return m_isDeleted;
			} 

			set 
			{
				m_isDeleted = value;
			}
		}

		/// <summary>
		/// Returns the time stamp of the data 
		/// </summary>
		public byte[] TimeStamp
		{
			get
			{
				// make copy of the time stamp byte array
				return m_timestamp;     //m_timeStamp.Clone()
			}

			set
			{
				m_timestamp = value;
			}
		}

	}

	/// <summary>
	/// Helper methods
	/// </summary>
	 public  class HelperMethods
	{
		/// <summary>
		/// Helper method to deep clone a specified object.
		/// </summary>
		/// <param name="objectToClone">Object to clone.</param>
		/// <returns></returns>
		public static object Clone(object objectToClone)
		{	
			//First we create an instance of this specific type.
			object newObject  = Activator.CreateInstance( objectToClone.GetType() );

			//We get the array of fields for the new type instance.
			FieldInfo[] fields = newObject.GetType().GetFields();

			int i = 0;
			
			foreach( FieldInfo fi in objectToClone.GetType().GetFields() )
			{				
				//We query if the fiels support the ICloneable interface.
				Type ICloneType = fi.FieldType.GetInterface( "ICloneable" , true );

				if( ICloneType != null )
				{
					//Getting the ICloneable interface from the object.
					ICloneable IClone = (ICloneable)fi.GetValue(objectToClone);

					//We use the clone method to set the new value to the field.
					fields[i].SetValue( newObject , IClone.Clone() );
				}
				else
				{
					//If the field doesn't support the ICloneable interface then just set it.
					fields[i].SetValue( newObject , fi.GetValue(objectToClone) );
				}

				//Now we check if the object support the IEnumerable interface, so if it does
				//we need to enumerate all its items and check if they support the ICloneable interface.
				Type IEnumerableType = fi.FieldType.GetInterface( "IEnumerable" , true );
				if( IEnumerableType != null )
				{
					//Get the IEnumerable interface from the field.
					IEnumerable IEnum = (IEnumerable)fi.GetValue(objectToClone);

					//This version support the IList and the IDictionary interfaces to iterate
					//on collections.
					Type IListType = fields[i].FieldType.GetInterface( "IList" , true );
					Type IDicType = fields[i].FieldType.GetInterface( "IDictionary" , true );

					int j = 0;
					if( IListType != null )
					{
						//Getting the IList interface.
						IList list = (IList)fields[i].GetValue(newObject);
						
						foreach( object obj in IEnum )
						{
							//Checking to see if the current item support the ICloneable interface.
							ICloneType = obj.GetType().GetInterface( "ICloneable" , true );

							if( ICloneType != null )
							{	
								//If it does support the ICloneable interface, we use it to set the clone of
								//the object in the list.
								ICloneable clone = (ICloneable)obj;

								list[j] = clone.Clone();								
							}
							
							//NOTE: If the item in the list is not support the ICloneable interface then
							// in the cloned list this item will be the same item as in the original list
							//(as long as this type is a reference type).

							j++;
						}
					}
					else if( IDicType != null )
					{
						//Getting the dictionary interface.
						IDictionary dic = (IDictionary)fields[i].GetValue(newObject);
						j = 0;
						foreach( DictionaryEntry de in IEnum )
						{
							//Checking to see if the item support the ICloneable interface.
							ICloneType = de.Value.GetType().GetInterface( "ICloneable" , true );

							if( ICloneType != null )
							{
								ICloneable clone = (ICloneable)de.Value;

								dic[de.Key] = clone.Clone();								
							}
							j++;
						}
					}
				}
				i++;			
			}
			return newObject;
		}
	}
}