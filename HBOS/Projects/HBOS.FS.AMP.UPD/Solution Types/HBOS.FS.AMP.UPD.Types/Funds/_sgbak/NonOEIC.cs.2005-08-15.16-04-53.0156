using System;
using System.Collections;
using HBOS.FS.AMP.UPD.Types.AssetFunds;
using HBOS.FS.AMP.UPD.Types.Factors;

namespace HBOS.FS.AMP.UPD.Types.Funds
{
	/// <summary>
	/// This class holds the commonanality between non OEIC funds
	/// </summary>
	public abstract class NonOEIC : Fund
	{
		/// <summary>
		/// Default constructor for the linked fund
		/// </summary>
		public NonOEIC() : base()
		{
		}

		/// <summary>
		/// Creates a new linked fund
		/// </summary>
		/// <param name="hiPortfolioCode"></param>
		/// <param name="fullName"></param>
		/// <param name="shortName"></param>
		/// <param name="classOrSeriesCode"></param>
		/// <param name="useMidPriceAsBidPrice"></param>
		/// <param name="onHiPortfolio3"></param>
		/// <param name="isDualPrice"></param>
		/// <param name="parentAssetFund"></param>
		/// <param name="assetMovementTolerance"></param>
		/// <param name="upperTolerance"></param>
		/// <param name="lowerTolerance"></param>
		/// <param name="priceIncreaseOnly"></param>
		/// <param name="tolerancesID"></param>
		/// <param name="price"></param>
		/// <param name="priceSet"></param>
		/// <param name="importedFundPriceID"></param>
		/// <param name="valuationBasisEffect"></param>
		/// <param name="previousPrice"></param>
		/// <param name="previousPriceSet"></param>
		/// <param name="fundStatus"></param>
		/// <param name="statusChangedTime"></param>
		/// <param name="statusChangedTimeSet"></param>
		/// <param name="usePredictedPrice"></param>
		/// <param name="authorisedPriceTimestamp"></param>
		/// <param name="timestamp"></param>
		/// <param name="isLife"></param>
		/// <param name="parentAssetFundID"></param>
		/// <param name="companyCode">Used for static data report. Null is acceptable for all other uses</param>
		/// <param name="securityCode"></param>
		/// <param name="isBenchmarkable"></param>
		/// <param name="factors"></param>
		public NonOEIC(string hiPortfolioCode, string fullName, string shortName, 
		                  string classOrSeriesCode, bool useMidPriceAsBidPrice,
		                  bool onHiPortfolio3, bool isDualPrice, AssetFund parentAssetFund, 			
		                  decimal assetMovementTolerance, decimal upperTolerance, decimal lowerTolerance,
		                  bool priceIncreaseOnly, Int64 tolerancesID, decimal price, bool priceSet,
		                  long importedFundPriceID,
		                  decimal valuationBasisEffect, decimal previousPrice, bool previousPriceSet, FundStatusType fundStatus, DateTime statusChangedTime,
		                  bool statusChangedTimeSet, bool usePredictedPrice, byte[] authorisedPriceTimestamp,
		                  byte[] timestamp, bool isLife, string parentAssetFundID, string companyCode, string securityCode, FactorCollection factors, bool isBenchmarkable)
			: base(hiPortfolioCode, fullName, shortName, 
			       classOrSeriesCode, onHiPortfolio3, parentAssetFund, 	
			       assetMovementTolerance, upperTolerance,
			       lowerTolerance, priceIncreaseOnly, tolerancesID, price, priceSet,
			       importedFundPriceID, valuationBasisEffect, previousPrice, previousPriceSet, fundStatus, statusChangedTime, statusChangedTimeSet,
			       usePredictedPrice, authorisedPriceTimestamp, timestamp, parentAssetFundID, companyCode, securityCode, factors, isBenchmarkable)
		{
			this.m_useMidPriceAsBidPrice = useMidPriceAsBidPrice;
			this.m_isDualPrice = isDualPrice;
			this.m_isLife = isLife;
			
		}




		private bool m_useMidPriceAsBidPrice = false;
		private bool m_isDualPrice = false;
		private bool m_isLife = false;

		/// <summary>
		/// The string representation of the type name used for display and reporting purposes
		/// </summary>
		public override string FundType
		{
			get
			{
				return "Linked";
			}
			//todo - do we need a set for the grid?
		}

		/// <summary>
		/// The price type (eg. single (S) or dual (D)).
		/// </summary>
		public bool IsDualPrice
		{
			get
			{
				return this.m_isDualPrice;
			}

			set
			{
				this.m_isDualPrice = value;
				this.setDirtyFlag();
			}
		}

		/// <summary>
		/// Flag indicating whether the mid price should be used as the bid price or not.
		/// </summary>
		public bool UseMidPriceAsBidPrice
		{
			get
			{
				return this.m_useMidPriceAsBidPrice;
			}

			set
			{
				this.m_useMidPriceAsBidPrice = value;
				this.setDirtyFlag();
			}
		}


		/// <summary>
		/// Flag indicating whether the fund can be used for life polices.
		/// </summary>
		public bool IsLife
		{
			get
			{
				return this.m_isLife;
			}

			set
			{
				this.m_isLife = value;
				this.setDirtyFlag();
			}
		}

//		/// <summary>
//		/// Gets the unique db id for the revaluation factor
//		/// </summary>
//		public int RevaluationFactorID
//		{
//			get
//			{
//				return m_factors.RevaluationFctr.FactorID;
//			}
//			
//			set
//			{
//				m_factors.RevaluationFctr.FactorID = value;
//			}
//
//		}
	
		/// <summary>
		/// Flag to indicate whether the revaluation change has been set because the default may be a
		/// valid value.
		/// </summary>
		public bool RevaluationFactorIDSet
		{
			get
			{
				return m_factors.RevaluationFctr.FactorIDSet;
			}
		}

		/// <summary>
		/// The start date of the revaluation period.
		/// </summary>
		public DateTime RevaluationEffectiveDate
		{
			get
			{
				return m_factors.RevaluationFctr.EffectiveDate;
			}

			set
			{
				m_factors.RevaluationFctr.EffectiveDate = value;
				this.setDirtyFlag();
			}
		}

		/// <summary>
		/// Flag to indicate whether the revaluation effective date has been set because the default
		/// may be a valid value.
		/// </summary>
		public bool RevaluationEffectiveDateSet
		{
			get
			{
				return m_factors.RevaluationFctr.EffectiveDateSet;
			}
		}

		/// <summary>
		/// The number of days that the revaluation period runs for.
		/// </summary>
		public DateTime RevaluationEndDate
		{
			get
			{
				return m_factors.RevaluationFctr.EndDate;
			}

			set
			{
				m_factors.RevaluationFctr.EndDate = value;
				this.setDirtyFlag();
			}
		}

		/// <summary>
		/// Flag to indicate whether the revaluation working days have been set because the default
		/// may be a valid value.
		/// </summary>
		public bool RevaluationEndDateSet
		{
			get
			{
				return m_factors.RevaluationFctr.EndDateSet;
			}
		}

		/// <summary>
		/// The calculated revaluation factor used in price prediction.
		/// </summary>
		public decimal RevalFactor
		{
			get
			{
				return this.m_factors.RevaluationFctr.RatioValue;
			}

			set
			{
				//todo - does grid cause this to be set & therefore dirty flag to be set unnecessarily
				this.m_factors.RevaluationFctr.RatioValue = value;
				this.setDirtyFlag();
			}
		}

		/// <summary>
		/// The revaluation factor as a percentage, rather than a ratio(factor) of 1
		/// </summary>
		public decimal RevalFactorPercent
		{
			get
			{
				return this.m_factors.RevaluationFctr.PercentValue;
			}

			set
			{
				this.m_factors.RevaluationFctr.PercentValue = value;
				this.setDirtyFlag();
			}
		}

		/// <summary>
		/// returns whether or not current reval factor is valid
		/// </summary>
		/// <returns></returns>
		public bool RevaluationFactorValid ()
		{
			return this.m_factors.RevaluationFctr.IsValid();
		}

		/// <summary>
		/// gets / sets the list of bank holidays, which is required for validation purposes.
		/// Only sets them on reval factor at present as others have no need.
		/// </summary>
		public Hashtable Holidays
		{
			get 
			{
				return this.m_factors.RevaluationFctr.Holidays;
			}
			set
			{
				m_factors.RevaluationFctr.Holidays = value;
			}
		}

		/// <summary>
		/// The scaling factor used for this fund in price prediction calculations.
		/// </summary>
		public decimal ScaleFactor
		{
			get
			{
				return this.m_factors.ScalingFctr.RatioValue;
			}

			set
			{
				this.m_factors.ScalingFctr.RatioValue = value;
				this.setDirtyFlag();
			}
		}

		/// <summary>
		/// The scaling factor as a percentage, rather than a ratio(factor) of 1
		/// </summary>
		public decimal ScaleFactorPercent
		{
			get
			{
				return this.m_factors.ScalingFctr.PercentValue;
			}

			set
			{
				this.m_factors.ScalingFctr.PercentValue = value;
				this.setDirtyFlag();
			}
		}

//		/// <summary>
//		/// The ID for the scaling factor used in the price calculation.
//		/// </summary>
//		public int ScalingFactorID
//		{
//			get
//			{
//				return this.m_factors.ScalingFctr.FactorID;
//			}
//
//			
//			set
//			{
//				this.m_factors.ScalingFctr.FactorID = value;
//			}
//		}

		/// <summary>
		/// Flag to indicate whether the scaling factor ID is a valid value or not.
		/// </summary>
		public bool ScalingFactorIDSet
		{
			get
			{
				return this.m_factors.ScalingFctr.FactorIDSet;
			}

		}

		/// <summary>
		/// returns whether or not current scaling factor is valid
		/// </summary>
		/// <returns></returns>
		public bool ScalingFactorValid ()
		{
			return this.m_factors.ScalingFctr.IsValid();
		}

		/// <summary>
		/// The tax provision estimate
		/// </summary>
		public decimal TPE
		{
			get
			{
				return this.m_factors.TPE.RatioValue;
			}

			set
			{
				this.m_factors.TPE.RatioValue = value;
				this.setDirtyFlag();
			}
		}

		/// <summary>
		/// The tax provision estimate as a percentage, rather than a ratio(factor) of 1
		/// </summary>
		public decimal TPEPercent
		{
			get
			{
				return this.m_factors.TPE.PercentValue;
			}

			set
			{
				this.m_factors.TPE.PercentValue = value;
				this.setDirtyFlag();
			}
		}

//		/// <summary>
//		/// The ID for the tax provision estimate used in the price calculation.
//		/// </summary>
//		public int TaxProvisionFactorID
//		{
//			get
//			{
//				return this.m_factors.TPE.FactorID;
//			}
//
//			
//			set
//			{
//				this.m_factors.TPE.FactorID = value;
//			}
//		}

		/// <summary>
		/// Flag indicating whether the tax provision estimate ID holds a valid value or not.
		/// </summary>
		private bool TaxProvisionFactorIDSet
		{
			get
			{
				return this.m_factors.TPE.FactorIDSet;
			}

		}

		/// <summary>
		/// returns whether or not current tax provision estimate is valid
		/// </summary>
		/// <returns></returns>
		public bool TPEValid ()
		{
			return this.m_factors.TPE.IsValid();
		}

		/// <summary>
		/// The formatted field used to display the Tax Provision Estimate.
		/// </summary>
		public string TPEDisplay
		{
			get
			{
				return DisplayFormat.Percent(this.TPE, (this.TaxProvisionFactorIDSet));
			}
		}

		/// <summary>
		/// as above but displays 0 as opposed to unavailable
		/// </summary>
		public string TPEDisplay2
		{
			get
			{
				return DisplayFormat.Percent(this.TPE, true);
			}
		}

		/// <summary>
		/// The formatted field used to display the Revaluation Factor.
		/// </summary>
		public string RevaluationFactorDisplay
		{
			get
			{
				return DisplayFormat.Percent(this.RevalFactor, (this.RevaluationFactorIDSet));
			}
		}

		/// <summary>
		/// as above but displays 0 as opposed to unavailable
		/// </summary>
		public string RevaluationFactorDisplay2
		{
			get
			{
				return DisplayFormat.Percent(this.RevalFactor, true);
			}
		}

		/// <summary>
		/// The formatted field used to display the Revaluation Factor Effective Date.
		/// </summary>
		public string RevaluationEffectiveDateDisplay
		{
			get
			{
				return DisplayFormat.ShortDate(this.RevaluationEffectiveDate, (this.RevaluationEffectiveDateSet));
			}
		}

		/// <summary>
		/// The formatted field used to display the Revaluation Factor End Date.
		/// </summary>
		public string RevaluationEndDateDisplay
		{
			get
			{
				return DisplayFormat.ShortDate(this.RevaluationEndDate, (this.RevaluationEndDateSet));
			}
		}

		/// <summary>
		/// Displays a Y or N depending on whether the fund is a life fund
		/// </summary>
		public string IsLifeDisplay
		{
			get
			{
				return this.IsLife ? "Y" : "N";
			}
		}

		/// <summary>
		/// Displays a Y or N 
		/// </summary>
		public string IsDualPriceDisplay
		{
			get
			{
				return this.IsDualPrice ? "Y" : "N";
			}
		}

		/// <summary>
		/// Displays a Y or N depending on whether the fund is a life fund
		/// </summary>
		public string UseMidPriceAsBidPriceDisplay
		{
			get
			{
				return this.UseMidPriceAsBidPrice ? "Y" : "N";
			}
		}

		/// <summary>
		/// The formatted field used to display the Scaling factor
		/// </summary>
		public string ScalingFactorDisplay
		{
			get
			{
				//display a 0 instead of 'unavailable'
				return DisplayFormat.Percent(this.ScaleFactor, true);
			}
		}

		/// <summary>
		/// Calculates the predicted price (is a derived property)
		/// </summary>
		public override decimal PredictedPrice
		{
			get
			{				
				//TPE effect is the only thing that differs between Composite pred price
				//and base predicted price. 
				//This is catered for in predictedMovemnt, therefore
				//we can just call the base here.

				//Predicted Price Today = 
				//	Previous day's autorised price * (1 + predictedMovement)
				//		where predictedMovement = (Asset Movement + Sum of Factors (excluding TPE)) * (1 - TPE)	

				return base.PredictedPrice;
			}

			
			set
			{
				//do nothing - it's a derived value. This is left in for the grid
			}
		}

		/// <summary>
		/// calculates the predicted movement to be applied to the price in order to calculate predicted price
		/// </summary>
		protected override decimal predictedMovement 
		{
			get 
			{
				return base.predictedMovement * m_factors.TPE.CalculateEffect();
			}
		}
	}
}