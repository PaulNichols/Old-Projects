using System;
using System.Data;
using System.Data.SqlClient;
using System.Globalization;
using HBOS.FS.AMP.Entities;
using HBOS.FS.AMP.UPD.Exceptions;
using HBOS.FS.AMP.UPD.Types.Users;
using HBOS.FS.Support.Tex;
using Microsoft.ApplicationBlocks.Data;

namespace HBOS.FS.AMP.UPD.Persistence
{
	/// <summary>
	/// This is the persister object for saving/retireing user data from/to the datasource 
	/// </summary>
	public class UserPersister : Persister
	{
		#region Constructors

		/// <summary>
		/// Constructor used to initialise the ConnectionString property
		/// </summary>
		/// <param name="connectionString"></param>
		public UserPersister(string connectionString) : base(connectionString)
		{
		}

		#endregion

		#region Load Methods

	
		/// <summary>
		/// Loads the a single user by Login ID.
		/// </summary>
		/// <param name="loginId">Login id.</param>
		/// <param name="companyCode">Company code.</param>
		/// <returns></returns>
		public User LoadUser(string loginId,string companyCode)
		{
			T.E();
			const string spName = "usp_UserGetStaticData";
			SqlParameter[] spParameters = new SqlParameter[2];

			// Set up the stored procedure parameters.
			spParameters[0] = new SqlParameter("@loginId", SqlDbType.VarChar, 50); 
			spParameters[0].Value = loginId;
			spParameters[1] = new SqlParameter("@companyCode", SqlDbType.VarChar, 10); 
			spParameters[1].Value = companyCode;
			// Create the fund object.
			User user = null;

			try
			{
				user = (User)this.LoadEntity(spName, spParameters);

				// Test for valid object
				if (user == null) 
				{
					throw new ArgumentException(string.Format("Failed to load a user with the login Id '{0}'",loginId));
				}
			}
			catch(SqlException ex)
			{
				ThrowDBException (ex, spName, spParameters);
			}
			T.X();
			return user;
		}

		/// <summary>
		/// This retrieves all the users for a company
		/// </summary>
		/// <param name="companyCode"></param>
		/// <returns>UserCollection</returns>
		public UserCollection LoadAllUsersForCompany(string companyCode)
		{
			T.E();
			SqlParameter[] parameters = new SqlParameter[1];

			// Set up the parameters.
			parameters[0] = new SqlParameter("@sCompanyCode", SqlDbType.VarChar, 10);
			parameters[0].Value = companyCode;

			// Create the users collection.
			UserCollection users = new UserCollection();
			this.LoadEntityCollection("usp_UserPermissionsPerCompanyListForEverybody", parameters, users);

			T.X();

			return users;
		}

		/// <summary>
		/// Creates a user from the supplied data
		/// </summary>
		/// <param name="reader">The reader containing the data.</param>
		/// <returns></returns>
		protected override object CreateEntity(SafeDataReader reader)
		{
			T.E();
			User newUser = new User(
				reader.GetString("loginID"),
				reader.GetString("userName"),
				reader.GetBoolean("deleted"),
				reader.GetString("userLastChangedBy"),
				reader.GetDateTime("userLastChangedDate"),
				reader.GetTimestamp("userTS")
				);

			newUser.Permissions = new UserPermissions(
				reader.GetBoolean("administrator"),
				reader.GetBoolean("importExchangeRate"),
				reader.GetBoolean("importMarketIndices"),
				reader.GetBoolean("importLinkedPrices"),
				reader.GetBoolean("importCompositePrices"),
				reader.GetBoolean("importHI3Prices"),
				reader.GetBoolean("importOverSeasFundWeightings"),
				reader.GetBoolean("ExportOEICPrices"),
				reader.GetBoolean("AuthorisePrices"),
				reader.GetBoolean("ReleasePrices"),
				reader.GetBoolean("DistributePrices"),
				reader.GetBoolean("MaintainFundGroups"),
				reader.GetBoolean("MaintainAssetFunds"),
				reader.GetBoolean("MaintainFundMappings"),
				reader.GetBoolean("MaintainDistributionSubscriptions"),
				reader.GetBoolean("MaintainDistributionMethods"),
				reader.GetBoolean("MaintainDistributionSubscribers"),
				reader.GetBoolean("MaintainUserAccess"),
				reader.GetBoolean("MaintainValidationTolerances"),
				reader.GetBoolean("MaintainCalculationIndices"),
				reader.GetBoolean("MaintainCalculationFactors"),
				reader.GetBoolean("ImportCompositeSplits"),
				reader.GetBoolean("ReExportPrices"),
				reader.GetString("companyCode"),
				reader.GetString("lastChangedBy"),
				reader.GetDateTime("lastChangedDate"),
				reader.GetTimestamp("ts")
				);

			T.X();
			return newUser;
		}

		#endregion

		#region ExceptionHandling

		/// <summary>
		/// Override the base database exception message
		/// </summary>
		/// <returns>String</returns>
		protected override string GetDatabaseExceptionMessage()
		{
			return "Failed to build the users list";
		}

		#endregion

		#region Update Methods

		/// <summary>
		/// This routine receives a collection of users to be peristed to the datasource
		/// </summary>
		/// <param name="users">List of users to save</param>
		public void Save(UserCollection users)
		{
			this.SaveEntityCollection(users);
		}

		/// <summary>
		/// Insert a new user into the database
		/// </summary>
		/// <param name="transaction">The transaction used for the persistence, allowing transactional rollback.</param>
		/// <param name="entity">Persitee user object</param>
		/// <returns>Success flag</returns>
		protected override void InsertEntity(IEntityBase entity, SqlTransaction transaction)
		{
			T.E();
			if (entity == null) throw new ArgumentNullException("entity", "Cannot insert null User");
			if (!(entity is User)) throw new ArgumentException("Incorrect type, expecting User, was " + entity.GetType().ToString(), "entity");
			User user = (User) entity;

			if (user.LogOnID == string.Empty || user.UserName == string.Empty)
			{
				throw new UsersSaveException("Both the User Name and Login must be populated", user);
			}

			//pjn added ***************************
			SqlParameter[] spParams = new SqlParameter[1];
			spParams[0] = new SqlParameter("@sLoginID", SqlDbType.VarChar, 50);
			spParams[0].Value = user.LogOnID;
			int rowCount = (int) SqlHelper.ExecuteScalar(transaction, CommandType.StoredProcedure, "usp_DoesUserExistForLoginID", spParams);

			if (rowCount == 0)
			{
				//user does not exist so save both the user and permissions

				// Create parameter object
				spParams = new SqlParameter[2];

				// This will make adding/moving/copying rows easier!!
				int paramCounter = 0;

				// Build parameters
				spParams[paramCounter] = new SqlParameter("@sLoginID", SqlDbType.VarChar, 50);
				spParams[paramCounter++].Value = user.LogOnID;
				spParams[paramCounter] = new SqlParameter("@sUserName", SqlDbType.VarChar, 50);
				spParams[paramCounter++].Value = user.UserName;


				// Call create stored procedure
				try
				{
					T.Log("Executing stored procedure: usp_UsersCreate");
					SqlHelper.ExecuteNonQuery(transaction, CommandType.StoredProcedure, "usp_UsersCreate", spParams);

					// Create parameter permission object
					spParams = UserPersister.permissionsParameters(user);

					// Call add user permissions for company
					T.Log("Executing stored procedure: usp_UserPermissionsPerCompanyAdd");
					SqlHelper.ExecuteNonQuery(transaction, CommandType.StoredProcedure, "usp_UserPermissionsPerCompanyAdd", spParams);
				}
				catch (SqlException ex)
				{
					this.ThrowDBException(ex, ex.Procedure, spParams);
				}
				finally
				{
					T.Log("Create user for login id: " + user.LogOnID);
					T.X();
				}
			}
			else if (rowCount == 1)
			{
				//the user exists does it have permisions for the current company

				spParams = new SqlParameter[2];
				spParams[1] = new SqlParameter("@sCompanyCode", SqlDbType.VarChar, 12);
				spParams[1].Value = user.Permissions.CompanyCode;
				spParams[0] = new SqlParameter("@sloginID", SqlDbType.VarChar, 50);
				spParams[0].Value = user.LogOnID;
				rowCount = (int) SqlHelper.ExecuteScalar(transaction, CommandType.StoredProcedure, "usp_UserPermissionsPerCompanyListForUserCount", spParams);

				if (rowCount == 1)
				{
					//if the user exists with permission for this company then throw an exception
					throw new Exception("A User with permissions for this company already exists.");
				}
				else if (rowCount == 0)
				{
					//if the user exists but with no permission for this company then add the permissions to the existing user
					// Create parameter permission object
					spParams = UserPersister.permissionsParameters(user);

					// Call add user permissions for company
					T.Log("Executing stored procedure: usp_UserPermissionsPerCompanyAdd");
					SqlHelper.ExecuteNonQuery(transaction, CommandType.StoredProcedure, "usp_UserPermissionsPerCompanyAdd", spParams);

				}
			}
			else
			{
				throw new Exception("Too many Users with the same details were found in the DB.");
			}
			//*****************************

		}

		/// <summary>
		/// Delete a specified user from the database.
		/// </summary>
		/// <param name="transaction">The transaction used for the persistence, allowing transactional rollback.</param>
		/// <param name="entity">Persitee user object</param>
		/// <returns>Success flag</returns>
		protected override void DeleteEntity(IEntityBase entity, SqlTransaction transaction)
		{
			T.E();
			if (entity == null) throw new ArgumentNullException("entity", "Cannot insert null User");
			if (!(entity is User)) throw new ArgumentException("Incorrect type, expecting User, was " + entity.GetType().ToString(), "entity");
			User user = (User) entity;

			SqlParameter[] spParams = new SqlParameter[2];
			int paramCounter = 0;

			spParams[paramCounter] = new SqlParameter("@sLoginID", SqlDbType.VarChar, 50);
			spParams[paramCounter++].Value = user.LogOnID;
			spParams[paramCounter] = new SqlParameter("@ts", SqlDbType.Timestamp);
			spParams[paramCounter++].Value = user.TimeStamp;

			try
			{
				T.Log("Executing stored procedure: usp_UsersDelete");
				SqlHelper.ExecuteNonQuery(transaction, CommandType.StoredProcedure, "usp_UsersDelete", spParams);
			}
			catch (SqlException ex)
			{
				this.ThrowDBException(ex, ex.Procedure, spParams);
			}
			finally
			{
				T.Log("Delete user: " + user.LogOnID);
				T.X();
			}
		}

		/// <summary>
		/// Update a user in the database
		/// </summary>
		/// <param name="transaction">The transaction used for the persistence, allowing transactional rollback.</param>
		/// <param name="entity">Persitee user object</param>
		protected override void UpdateEntity(IEntityBase entity, SqlTransaction transaction)
		{
			T.E();
			if (entity == null) throw new ArgumentNullException("entity", "Cannot insert null User");
			if (!(entity is User)) throw new ArgumentException("Incorrect type, expecting User, was " + entity.GetType().ToString(), "entity");
			User user = (User) entity;

			SqlParameter[] spParams = new SqlParameter[4];
			int paramCounter = 0;

			spParams[paramCounter] = new SqlParameter("@sLoginID", SqlDbType.VarChar, 50);
			spParams[paramCounter++].Value = user.LogOnID;

			spParams[paramCounter] = new SqlParameter("@sUserName", SqlDbType.VarChar, 50);
			spParams[paramCounter++].Value = user.UserName;

			spParams[paramCounter] = new SqlParameter("@bDeleted", SqlDbType.Bit);
			spParams[paramCounter++].Value = user.IsDeleted;

			spParams[paramCounter] = new SqlParameter("@ts", SqlDbType.Timestamp);
			spParams[paramCounter].Direction = ParameterDirection.InputOutput;
			spParams[paramCounter].Value = user.TimeStamp;

			try
			{
				// Call update stored procedure
				if (user.IsDirty)
				{
					SqlHelper.ExecuteScalar(transaction, CommandType.StoredProcedure, "usp_UsersUpdate", spParams);
					user.TimeStamp = (byte[]) spParams[3].Value;
					user.IsDirty = false;
				}

			}
			catch (SqlException ex)
			{
				this.ThrowDBException(ex, ex.Procedure, spParams);
			}
			finally
			{
				T.Log("Update user: " + user.LogOnID);
				T.X();
			}
		}

		/// <summary>
		/// Overriden to ensure an update if only the permissions have changed
		/// </summary>
		/// <param name="entity">User entity.</param>
		/// <param name="transaction">Transaction.</param>
		protected internal override void SaveEntity(IEntityBase entity, SqlTransaction transaction)
		{
			T.E();
			base.SaveEntity(entity, transaction);

			if (!(entity is User)) throw new ArgumentException("Incorrect type, expecting User, was " + entity.GetType().ToString(), "entity");
			User user = (User) entity;
			SqlParameter[] spParams = null;

			try
			{
				if (user.Permissions.IsDeleted)
				{
					spParams = new SqlParameter[3];
					spParams[0] = new SqlParameter("@sLoginID", SqlDbType.VarChar, 50);
					spParams[1] = new SqlParameter("@sCompanyCode", SqlDbType.VarChar, 10);
					spParams[2] = new SqlParameter("@ts", SqlDbType.Timestamp);

					spParams[0].Value = user.LogOnID;
					spParams[1].Value = user.Permissions.CompanyCode;
					spParams[2].Value = user.Permissions.TimeStamp;

					SqlHelper.ExecuteNonQuery(transaction, CommandType.StoredProcedure, "usp_UserPermissionsPerCompanyDelete", spParams);

				}
				else if (user.Permissions.IsDirty & !user.IsNew)
				{
					spParams = UserPersister.permissionsParameters(user);
					SqlHelper.ExecuteNonQuery(transaction, CommandType.StoredProcedure, "usp_UserPermissionsPerCompanyUpdate", spParams);
					user.TimeStamp = (byte[]) spParams[spParams.GetUpperBound(0)].Value;
					user.IsDirty = false;

				}
			}
			catch (SqlException ex)
			{
				this.ThrowDBException(ex, ex.Procedure, spParams);
			}
			T.X();
		}


		private static SqlParameter[] permissionsParameters(User userToPersist)
		{
			// This procedure centralises the building of the paramters
			// for the update/insert of the user permissions

			// we will now add the user permissions inside the same transaction
			// Create paremeter object

			SqlParameter[] spParams = null;
			// The update procedure also takes the timestamp field
			if (userToPersist.Permissions.IsDirty && userToPersist.IsNew == false)
			{
				spParams = new SqlParameter[26];
			}
			else
			{
				spParams = new SqlParameter[25];
			}

			// Build parameters
			spParams[0] = new SqlParameter("@sLoginID", SqlDbType.VarChar, 50);
			spParams[0].Value = userToPersist.LogOnID;

			spParams[1] = new SqlParameter("@sCompanyCode", SqlDbType.VarChar, 10);
			spParams[1].Value = userToPersist.Permissions.CompanyCode;

			spParams[2] = new SqlParameter("@bAdministrator", SqlDbType.Bit);
			spParams[2].Value = userToPersist.Permissions.Administrator;

			spParams[3] = new SqlParameter("@bImportExchangeRate", SqlDbType.Bit);
			spParams[3].Value = userToPersist.Permissions.ImportExchangeRates;

			spParams[4] = new SqlParameter("@bImportMarketIndices", SqlDbType.Bit);
			spParams[4].Value = userToPersist.Permissions.ImportMarketIndices;

			spParams[5] = new SqlParameter("@bImportHi3Prices", SqlDbType.Bit);
			spParams[5].Value = userToPersist.Permissions.CanImportOEICPrices;

			spParams[6] = new SqlParameter("@bImportOverseasFundWeightings", SqlDbType.Bit);
			spParams[6].Value = userToPersist.Permissions.ImportOverSeasFundWeightings;

			spParams[7] = new SqlParameter("@bAuthorisePrices", SqlDbType.Bit);
			spParams[7].Value = userToPersist.Permissions.AuthorisePrices;

			spParams[8] = new SqlParameter("@bReleasePrices", SqlDbType.Bit);
			spParams[8].Value = userToPersist.Permissions.ReleasePrices;

			spParams[9] = new SqlParameter("@bDistributePrices", SqlDbType.Bit);
			spParams[9].Value = userToPersist.Permissions.DistributePrices;

			spParams[10] = new SqlParameter("@bMaintainFundGroups", SqlDbType.Bit);
			spParams[10].Value = userToPersist.Permissions.MaintainFundGroups;

			spParams[11] = new SqlParameter("@bMaintainAssetFunds", SqlDbType.Bit);
			spParams[11].Value = userToPersist.Permissions.MaintainAssetFunds;

			spParams[12] = new SqlParameter("@bMaintainFundMappings", SqlDbType.Bit);
			spParams[12].Value = userToPersist.Permissions.MaintainFundMappings;

			spParams[13] = new SqlParameter("@bMaintainDistributionSubscriptions", SqlDbType.Bit);
			spParams[13].Value = userToPersist.Permissions.MaintainDistributionSubscriptions;

			spParams[14] = new SqlParameter("@bMaintainDistributionMethods", SqlDbType.Bit);
			spParams[14].Value = userToPersist.Permissions.MaintainDistributionMethods;

			spParams[15] = new SqlParameter("@bMaintainDistributionSubscribers", SqlDbType.Bit);
			spParams[15].Value = userToPersist.Permissions.MaintainDistributionSubscribers;

			spParams[16] = new SqlParameter("@bMaintainUserAccess", SqlDbType.Bit);
			spParams[16].Value = userToPersist.Permissions.MaintainUserAccess;

			spParams[17] = new SqlParameter("@bMaintainValidationTolerances", SqlDbType.Bit);
			spParams[17].Value = userToPersist.Permissions.MaintainValidationTolerances;

			spParams[18] = new SqlParameter("@bMaintainCalculationIndices", SqlDbType.Bit);
			spParams[18].Value = userToPersist.Permissions.MaintainCalculationIndices;

			spParams[19] = new SqlParameter("@bMaintainCalculationFactors", SqlDbType.Bit);
			spParams[19].Value = userToPersist.Permissions.MaintainCalculationFactors;

			spParams[20] = new SqlParameter("@bExportOEICPrices", SqlDbType.Bit);
			spParams[20].Value = userToPersist.Permissions.ExportOEICSPrices;

			spParams[21] = new SqlParameter("@bImportCompositeSplits", SqlDbType.Bit);
			spParams[21].Value = userToPersist.Permissions.ImportCompositeSplits;

			spParams[22] = new SqlParameter("@bReExportPrices", SqlDbType.Bit);
			spParams[22].Value = userToPersist.Permissions.ReExportPrices;

			spParams[23] = new SqlParameter("@bimportLinkedPrices", SqlDbType.Bit);
			spParams[23].Value = userToPersist.Permissions.CanImportLinkedPrices;

			spParams[24] = new SqlParameter("@bimportCompositePrices", SqlDbType.Bit);
			spParams[24].Value = userToPersist.Permissions.CanImportCompositePrices;

			// Updates need the timestamp as well - but not for new users
			if (userToPersist.Permissions.IsDirty && userToPersist.IsNew == false)
			{
				spParams[25] = new SqlParameter("@ts", SqlDbType.Timestamp);
				spParams[25].Direction = ParameterDirection.InputOutput;
				spParams[25].Value = userToPersist.Permissions.TimeStamp;
			}

			return spParams;
		}

		#endregion

		#region Other public methods

		/// <summary>
		/// Set the last company the user chose
		/// </summary>
		public string GetLastCompany()
		{
			string loadSp = "usp_UsersGetLastCompanyForLoginID";
			try
			{
				using (SqlDataReader companyReader = SqlHelper.ExecuteReader(
					this.ConnectionString,
					loadSp))
				{
					if (companyReader.Read())
						return companyReader["CompanyCode"].ToString();
				}
				return String.Empty;
			}
			catch (SqlException ex)
			{
				ThrowDBException(ex, loadSp, null);
			}
			finally
			{
				T.X();
			}
			return String.Empty;
		}

		/// <summary>
		/// Set the last company the user chose
		/// </summary>
		public void SetLastCompany(string companyCode)
		{
			string loadSp = "usp_UsersSetLastCompanyForLoginID";
			try
			{
				SqlParameter[] spParams = new SqlParameter[1];
				spParams[0] = new SqlParameter("@sCompanyID", SqlDbType.Char, 10);
				spParams[0].Value = companyCode;

				// And finally save the new company code against the user record in the database
				SqlHelper.ExecuteNonQuery(
					this.ConnectionString,
					CommandType.StoredProcedure,
					"usp_UsersSetLastCompanyForLoginID",
					spParams);
			}
			catch (SqlException ex)
			{
				ThrowDBException(ex, loadSp, null);
			}
			finally
			{
				T.X();
			}
		}

		/// <summary>
		/// Return the user permissions for the user and the current company
		/// </summary>
		/// <param name="companyId"></param>
		/// <returns></returns>
		public DataSet UserPermissions(string companyId)
		{
			string loadSp = "usp_userPermissionsPerCompanyListForUser";

			try
			{
				using (SqlConnection connection = new SqlConnection(this.ConnectionString))
				{
					using (SqlCommand command = new SqlCommand())
					{
						// Get the permissions record for the combination of 
						// the Identity user and specified company ID
						command.Connection = connection;
						command.CommandText = "usp_userPermissionsPerCompanyListForUser";
						command.CommandType = CommandType.StoredProcedure;
						command.Parameters.Add("@sCompanyCode", SqlDbType.VarChar, 50).Value = companyId;
						using (DataSet rolesDS = new DataSet())
						{
							rolesDS.Locale = CultureInfo.InvariantCulture;
							connection.Open();
							using (SqlDataAdapter roleDA = new SqlDataAdapter(command))
							{
								roleDA.Fill(rolesDS);
								return rolesDS;
							}
						}
					}
				}
			}
			catch (SqlException ex)
			{
				ThrowDBException(ex, loadSp, null);
			}
			finally
			{
				T.X();
			}
			return null;
		}

		/// <summary>
		/// 
		/// </summary>
		/// <returns></returns>
		public bool UserIsValid()
		{
			T.E();
			bool isValidUser = false;
			const string loadSp = "usp_userIsValid";
			try
			{
				using (SqlConnection connection = new SqlConnection(this.ConnectionString))
				{
					using (SqlCommand command = new SqlCommand())
					{
						command.Connection = connection;
						command.CommandText = loadSp;
						command.CommandType = CommandType.StoredProcedure;
						connection.Open();
						isValidUser = Convert.ToBoolean(command.ExecuteScalar(),
						                                CultureInfo.InvariantCulture);
						connection.Close();
					}
				}

			}
			catch (SqlException ex)
			{
				ThrowDBException(ex, loadSp, null);
			}
			finally
			{
				T.X();
			}
			return isValidUser;

		}

		#endregion

	
	}
}