using System;
using System.Data.SqlClient;
using HBOS.FS.AMP.UPD.Exceptions;
using HBOS.FS.AMP.UPD.Persistence;
using HBOS.FS.AMP.UPD.Types.AssetFunds;
using HBOS.FS.AMP.UPD.Types.Countries;
using HBOS.FS.AMP.UPD.Types.Funds;
using HBOS.FS.AMP.UPD.Types.Lookups;
using HBOS.FS.AMP.UPD.Types.Snapshot;
using HBOS.FS.Support.Tex;

namespace HBOS.FS.AMP.UPD.Controllers
{
	/// <summary>
	/// Summary description for AssetFundController.
	/// </summary>
	public class AssetFundController
	{
		#region Constructor

		/// <summary>
		/// Default constructor
		/// </summary>
		public AssetFundController()
		{
			//
			// TODO: Add constructor logic here
			//
		}

		#endregion

		#region Load methods

		/// <summary>
		/// Loads a list of asset funds for supplied company
		/// </summary>
		/// <param name="connectionString"></param>
		/// <param name="companyCode"></param>
		/// <returns></returns>
		public static SimpleStringLookupCollection LoadAssetFundLookupsByCompany(string connectionString, string companyCode)
		{
			AssetFundLookupPersister afLookup = new AssetFundLookupPersister(connectionString);
			return afLookup.LoadForCompany(companyCode);
		}

		/// <summary>
		/// Loads a list of asset funds for supplied company and type
		/// </summary>
		/// <param name="connectionString"></param>
		/// <param name="companyCode">The company code to filter by</param>
		/// <param name="assetFundType">The asset fund type to filter by</param>
		/// <returns></returns>
		public  static SimpleStringLookupCollection LoadAssetFundLookupsByCompanyAndType
			(string connectionString, string companyCode, AssetFund.AssetFundTypeEnum assetFundType)
		{
			AssetFundLookupPersister afLookup = new AssetFundLookupPersister(connectionString);
			return afLookup.LoadForCompany(companyCode, assetFundType);
		}

		/// <summary>
		/// Lightweight asset fund load (static data)
		/// </summary>
		/// <param name="connectionString"></param>
		/// <param name="assetFundID"></param>
		/// <returns></returns>
		public  static AssetFund LoadAssetFundForStaticData(string connectionString, string assetFundID)
		{
			AssetFundStaticDataPersister persister = new AssetFundStaticDataPersister(connectionString);
			return persister.Load(assetFundID);
		}

		/// <summary>
		/// Lightweight asset fund load (static data)
		/// </summary>
		/// <param name="connectionString"></param>
		/// <param name="companyCode"></param>
		/// <returns></returns>
		public static AssetFundCollection LoadAssetFundsByCompanyIdForStaticDataExport(string connectionString, string companyCode)
		{
			AssetFundStaticDataExportPersister persister = new AssetFundStaticDataExportPersister(connectionString);
			return persister.LoadForCompany(companyCode);
		}

		/// <summary>
		/// Get a collection of the asset funds from the database for a specified company
		/// </summary>
		/// <param name="connectionString">Valid database connection string</param>
		/// <param name="companyCode">The ID of the company for which the funds are to be retrieved</param>
		/// <param name="currentWeightings">Extract the most recent weightings<br />
		/// <list type="bullet">
		/// <item>
		/// <description>Pass in a value of <code>true</code> will extract the most recent weightings overriding any 
		/// indices that have authorised where there are more recent values</description>
		/// </item>
		/// <list type="bullet">
		/// <listheader>
		/// <description>Pass in a value of <code>false</code> will either</description>
		/// </listheader>
		/// <item>
		/// <description>Extract weightings for authorised indices only.</description>
		/// </item>
		/// <item>
		/// <description>Or, when there are no authorised indices for the most recent weightings</description>
		/// </item>
		/// </list>
		/// </list>
		/// </param>
		/// <returns>A collection of asset fund objects</returns>
		public  static AssetFundCollection LoadAssetFunds(string connectionString, string companyCode, bool currentWeightings)
		{
			AssetFundPricingPersister assetFunds = new AssetFundPricingPersister(connectionString);
			return assetFunds.LoadForCompany(companyCode, currentWeightings);
		}

		/// <summary>
		/// Get a collection of the asset funds from the database for a specified fund group
		/// </summary>
		/// <param name="connectionString">Valid DB connection string</param>
		/// <param name="fundGroupID">The ID of the fund group for which the funds are to be retrieved</param>
		/// <param name="currentWeightings">Extract the most recent weightings<br />
		/// <list type="bullet">
		/// <item>
		/// <description>Pass in a value of <code>true</code> will extract the most recent weightings overriding any 
		/// indices that have authorised where there are more recent values</description>
		/// </item>
		/// <list type="bullet">
		/// <listheader>
		/// <description>Pass in a value of <code>false</code> will either</description>
		/// </listheader>
		/// <item>
		/// <description>Extract weightings for authorised indices only.</description>
		/// </item>
		/// <item>
		/// <description>Or, when there are no authorised indices for the most recent weightings</description>
		/// </item>
		/// </list>
		/// </list>
		/// </param>
		/// <returns>A collection of asset fund objects</returns>
		public static AssetFundCollection LoadAssetFunds(string connectionString, int fundGroupID, bool currentWeightings)
		{
			AssetFundPricingPersister assetFunds = new AssetFundPricingPersister(connectionString);
			return assetFunds.Load(fundGroupID, currentWeightings);
		}

		/// <summary>
		/// Get the passed asset fund
		/// </summary>
		/// <param name="connectionString"></param>
		/// <param name="assetFundID"></param>
		/// <param name="currentWeightings"></param>
		/// <returns></returns>
		public  static AssetFund LoadAssetFund(string connectionString, string assetFundID, bool currentWeightings)
		{
			AssetFundPricingPersister persister = new AssetFundPricingPersister(connectionString);
			return persister.Load(assetFundID, currentWeightings);
		}


		#endregion

		#region Load lookup data

		/// <summary>
		/// Method to get a list of all the countries held in the DB
		/// </summary>
		/// <param name="connectionString">Valid DB connection string</param>
		/// <returns type="CountryCollection">A country collection object</returns>
		public static CountryCollection LoadCountries(string connectionString)
		{
			CountryPersister countries = new CountryPersister(connectionString);
			return countries.LoadCountries();
		}

		/// <summary>
		/// Loads the all available benchmarks.
		/// </summary>
		/// <param name="connectionString">Connection string.</param>
		/// <returns></returns>
		public static AssetMovementConstituentCollection LoadAllAvailableBenchmarks(string connectionString)
		{
			T.E();
			AssetMovementConstituentCollection parts = null;

			try
			{
				AssetMovementConstituentPersister amcp=new AssetMovementConstituentPersister(connectionString);
				parts = amcp.LoadAllBenchmarks();
			}
			finally
			{
				T.X();
			}
			return parts;
		}



		#endregion

		#region Update methods

		/// <summary>
		/// Saves a singular asset fund
		/// </summary>
		/// <param name="connectionString"></param>
		/// <param name="assetFund"></param>
		public static void UpdateAssetFund(string connectionString, AssetFund assetFund)
		{
			T.E();
			try
			{
				UpdateAssetFundAndChildFunds(connectionString,assetFund,null);
			}
			finally
			{
				T.X();
			}
		}

		/// <summary>
		/// Update the asset fund and associated funds
		/// </summary>
		/// <param name="connectionString"></param>
		/// <param name="assetFund"></param>
		/// <param name="childFunds"></param>
		public  static void UpdateAssetFundAndChildFunds(string connectionString, AssetFund assetFund, FundCollection childFunds)
		{
			T.E();
			SqlTransaction newTrans;
			InvalidFactorException factorEx = null;
			try
			{
				using (SqlConnection newConnection = new SqlConnection(connectionString))
				{
					// Establish the transaction object
					newConnection.Open();
					newTrans = newConnection.BeginTransaction();
					AssetFundStaticDataPersister updateAssetFunds = new AssetFundStaticDataPersister(connectionString);
					try
					{
						updateAssetFunds.Save(assetFund, newTrans);
						if (childFunds != null && childFunds.Count > 0)
						{
							FundStaticDataPersister fundPersister = new FundStaticDataPersister(connectionString);
							try
							{
								fundPersister.SaveFunds(childFunds, newTrans);
							}
							catch (InvalidFactorException ex)
							{
								//if we get this we still want to commit the transaction, but
								//we want rethrow it in order to inform calling client who can then inform the user
								//through the UI.
								//Once UI validation is completed we could remove this and just always 
								//treat this as an error and always fail.
								factorEx = ex;
							}

						}
						saveMovementConstituents(newTrans,assetFund);
						newTrans.Commit();
					}
					catch
					{
						newTrans.Rollback();
						throw;
					}
				}

			}
			finally
			{
				T.X();
			}
			if (factorEx != null)
			{
				throw factorEx;
			}
		}

		private static void saveMovementConstituents(SqlTransaction trans, AssetFund assetFund)
		{
			if (hasSplitChanged(assetFund.AssetMovementConstituents))
			{
				SnapshotPersister snapshotPersister = new SnapshotPersister(trans.Connection.ConnectionString);
				Snapshot snapshot = snapshotPersister.NewStaticDataSnapshot(assetFund.CompanyCode,trans);

				AssetMovementConstituentPersister movementPersister = new AssetMovementConstituentPersister(trans.Connection.ConnectionString);
				movementPersister.Save(assetFund.AssetMovementConstituents,snapshot,trans);

				snapshotPersister.Activate(snapshot,trans);
			}
		}

		private static bool hasSplitChanged(AssetMovementConstituentCollection constitution)
		{
			bool result = false;
			if (constitution != null)
			{
				result =constitution.IsDirty;
				if (result!=true)
				{
					foreach(AssetMovementConstituent constituent in constitution)
					{
						result = constituent.IsDeleted || constituent.IsDirty || constituent.IsNew;
						if (result) break;
					}
				}
			}
			return result;
		}

		#endregion 

		#region Validation Methods

		/// <summary>
		/// Indicates what type of error occurred 
		/// </summary>
		public enum AssetFundFieldValidationError
		{
			/// <summary>
			/// no error occurred
			/// </summary>
			NoError,
			/// <summary>
			/// a required field was not completed
			/// </summary>
			FieldEmpty,
			/// <summary>
			/// a unique field already exists in db
			/// </summary>
			DuplicateField
		}

		/// <summary>
		/// Indicates the type of market split error
		/// </summary>
		public enum AssetSplitProportionValidationError
		{
			/// <summary>
			///No error occurred 
			/// </summary>
			AssetFundNoError,
			/// <summary>
			/// market splits proportion total is less than 100%
			/// </summary>
			AssetFundLessThan100Percent,
			/// <summary>
			/// market splits proportion total is greater than 100%
			/// </summary>
			AssetFundMoreThan100Percent,
			/// <summary>
			/// a weighting must be valid to 4dp (6dp as a ratio)
			/// </summary>
			AssetFundInvalidNumDecimalPlaces,
			/// <summary>
			/// an item has a proportion value of 0
			/// </summary>
			AssetFundSingleProportionValueOfZero
		}

		/// <summary>
		/// validation enum for tolerance validation
		/// </summary>
		public enum ToleranceValidationError
		{
			/// <summary>
			/// no error occurred
			/// </summary>
			NoError,
			/// <summary>
			/// value higher than max
			/// </summary>
			MaxToleranceExceeded,
			/// <summary>
			/// tolerance must be provided
			/// </summary>
			AssetFundToleranceNegative,
			/// <summary>
			/// tolerance must be to 2dp
			/// </summary>
			AssetFundInvalidNumDecimalPlaces
		}

		private  static ToleranceValidationError validateTolerance(decimal tolerance)
		{
			T.E();
			ToleranceValidationError tolError = ToleranceValidationError.NoError;
			try
			{
				if (tolerance < 0)
				{
					tolError = ToleranceValidationError.AssetFundToleranceNegative;
				}
				else if (tolerance > MaxTolerance)
				{
					tolError = ToleranceValidationError.MaxToleranceExceeded;
				}
					//note for next line that we store tolerance as a ratio not a percentile (is to 4dp percentile)
				else if (tolerance != decimal.Parse(tolerance.ToString("#0.000000")))
				{
					tolError = ToleranceValidationError.AssetFundInvalidNumDecimalPlaces;
				}
			}
			finally
			{
				T.X();
			}
			return tolError;
		}

		/// <summary>
		/// The maximum upper tolerance allowed
		/// </summary>
		public static decimal MaxTolerance
		{
			get
			{
				return 99.999M; //9999.9%
			}
		}

		/// <summary>
		/// Validates that the short name is ok, the full name is ok, and that the market splits total 100%
		/// Precondition - full name and short name max length is validated prior to here (by restricting text field in UI)
		/// </summary>
		/// <param name="connection"></param>
		/// <param name="updatedAssetFund"></param>
		/// <param name="fullNameError"></param>
		/// <param name="shortNameError"></param>
		/// <param name="assetMovementToleranceError"></param>
		/// <param name="mktSplitProportionError"></param>
		/// <returns></returns>
		public static bool ValidateUpdatedAssetFund(string connection, AssetFund updatedAssetFund,
		                                     out AssetFundFieldValidationError fullNameError,
		                                     out AssetFundFieldValidationError shortNameError,
		                                     out ToleranceValidationError assetMovementToleranceError,
		                                     out AssetSplitProportionValidationError mktSplitProportionError)
		{
			T.E();
			bool isValid = true;
			fullNameError = AssetFundFieldValidationError.NoError;
			shortNameError = AssetFundFieldValidationError.NoError;
			assetMovementToleranceError = ToleranceValidationError.NoError;
			mktSplitProportionError = AssetSplitProportionValidationError.AssetFundNoError;
			try
			{
				bool fullNameExists = false;
				bool shortNameExists = false;
				AssetFundStaticDataPersister afPersister = new AssetFundStaticDataPersister(connection);
				afPersister.CheckFullNameOrShortNameDuplicationForExistingAssetFund(updatedAssetFund.AssetFundCode,
				                                                                    updatedAssetFund.FullName, updatedAssetFund.ShortName, out fullNameExists, out shortNameExists);

				if (updatedAssetFund.FullName.Length == 0)
				{
					isValid = false;
					fullNameError = AssetFundFieldValidationError.FieldEmpty;
				}
				else if (fullNameExists)
				{
					isValid = false;
					fullNameError = AssetFundFieldValidationError.DuplicateField;
				}

				if (updatedAssetFund.ShortName.Length == 0)
				{
					isValid = false;
					shortNameError = AssetFundFieldValidationError.FieldEmpty;

				}
				else if (shortNameExists)
				{
					isValid = false;
					shortNameError = AssetFundFieldValidationError.DuplicateField;
				}

				assetMovementToleranceError = validateTolerance(updatedAssetFund.AssetMovementTolerance);
				if (assetMovementToleranceError != ToleranceValidationError.NoError)
				{
					isValid = false;
				}

				mktSplitProportionError = ValidateBenchmarkValueSplit(updatedAssetFund);
				if (mktSplitProportionError != AssetSplitProportionValidationError.AssetFundNoError)
				{
					isValid = false;
				}
			}
			finally
			{
				T.X();
			}
			return isValid;

		}

		/// <summary>
		/// Validates data for the creation of a new asset fund. Accepts param data
		/// rather than an object as type also requires validation.
		/// Precondition - maxlength of fields validated in UI.
		/// </summary>
		/// <param name="connection"></param>
		/// <param name="assetFundID"></param>
		/// <param name="fullName"></param>
		/// <param name="shortName"></param>
		/// <param name="assetFundIDError"></param>
		/// <param name="fullNameError"></param>
		/// <param name="shortNameError"></param>
		/// <returns></returns>
		public  static bool ValidateNewAssetFund(string connection, string assetFundID, string fullName, string shortName,
		                                 out AssetFundFieldValidationError assetFundIDError,
		                                 out AssetFundFieldValidationError fullNameError,
		                                 out AssetFundFieldValidationError shortNameError)
			//out bool weightedMovementsOK)
		{
//											WeightedMovementCollection weightedMovements,

			T.E();
			bool isValid = true;
			//weightedMovementsOK = true;
			assetFundIDError = AssetFundFieldValidationError.NoError;
			fullNameError = AssetFundFieldValidationError.NoError;
			shortNameError = AssetFundFieldValidationError.NoError;
			try
			{
				//afTypeOK = true; //afType != AssetFundFactory.AssetFundType.unknown

				AssetFundPricingPersister afPersister = new AssetFundPricingPersister(connection);

				bool assetFundIDEXists;
				bool fullNameExists;
				bool shortNameExists;

				afPersister.CheckAssetFundExistence(assetFundID, fullName, shortName, out assetFundIDEXists, out fullNameExists, out shortNameExists);

				if (assetFundID.Length == 0)
				{
					isValid = false;
					assetFundIDError = AssetFundFieldValidationError.FieldEmpty;
				}
				else if (assetFundIDEXists)
				{
					isValid = false;
					assetFundIDError = AssetFundFieldValidationError.DuplicateField;
				}


				if (fullName == null || fullName.Length == 0)
				{
					isValid = false;
					fullNameError = AssetFundFieldValidationError.FieldEmpty;
				}
				else if (fullNameExists)
				{
					isValid = false;
					fullNameError = AssetFundFieldValidationError.DuplicateField;
				}

				if (shortName == null || shortName.Length == 0)
				{
					isValid = false;
					shortNameError = AssetFundFieldValidationError.FieldEmpty;

				}
				else if (shortNameExists)
				{
					isValid = false;
					shortNameError = AssetFundFieldValidationError.DuplicateField;
				}

			}
			finally
			{
				T.X();
			}
			return isValid;
		}

		/// <summary>
		/// Validate the market value split proportion value of the asset fund weighted
		/// indices.  This will ensure the sum of the proportion value adds up to 100%. 
		/// Note that this can only be validated for an updated asset fund - a new asset fund
		/// cannot have mv splits as its type has not been decide upon until saved
		/// </summary>
		/// <param name="updatedAssetFund"></param>
		/// <returns></returns>
		public  static AssetSplitProportionValidationError ValidateBenchmarkValueSplit(AssetFund updatedAssetFund)
		{
			AssetSplitProportionValidationError retValue = AssetSplitProportionValidationError.AssetFundNoError;
			decimal proportionSum = 0;
			T.E();
			try
			{
//				if (!(updatedAssetFund is CompositeAssetFund))
//				{
				AssetMovementConstituentCollection assetMovementConstituents=updatedAssetFund.AssetMovementConstituents;

				proportionSum = assetMovementConstituents.TotalProportion();

				if (assetMovementConstituents.DoAnyItemsHaveAProportionOfZero)
				{
					retValue=AssetSplitProportionValidationError.AssetFundSingleProportionValueOfZero;
				}

					
							
					//WeightedIndex wIdx = (WeightedIndex) marketIndices[i];
					//								try
					//								{
					//									if (wIdx.ProportionPercentage != decimal.Parse(wIdx.ProportionPercentageDisplay))
					//									{
					//										retValue = MarketSplitProportionValidationError.invalidNumDecimalPlaces;
					//										break;
					//									}
					//								}
					//								catch
					//								{
					//								}
							

				if (retValue == AssetSplitProportionValidationError.AssetFundNoError)
				{
					if (proportionSum < 1)
					{
						retValue = AssetSplitProportionValidationError.AssetFundLessThan100Percent;
					}
					else if (proportionSum > 1)
					{
						retValue = AssetSplitProportionValidationError.AssetFundMoreThan100Percent;
					}
				}
				}
				//					}
				//					else
				//					{
				//						//when the user updates they must provide some market value splits
				//						retValue = MarketSplitProportionValidationError.lessThan100Percent;
				//					}
//			}
		
			finally
			{
				T.X();
			}

			return retValue;
		}

		#endregion

		/// <summary>
		/// Updates the movement constituents.
		/// </summary>
		/// <param name="parts">Parts.</param>
		/// <param name="fund">Fund.</param>
		/// <param name="connectionString">Connection string.</param>
		public static void UpdateMovementConstituents(AssetMovementConstituentCollection parts, AssetFund fund, string connectionString)
		{
			throw new NotImplementedException();
		}

		/// <summary>
		/// This delegate is used to Asynchronously Load All benchmarks
		/// </summary>
		public delegate AssetMovementConstituentCollection LoadAllBenchMarksDelegate (string connectionString);


		/// <summary>
		/// Begins the load all available benchmarks.
		/// </summary>
		/// <param name="connectionString">Connection string.</param>
		/// <returns></returns>
		public static IAsyncResult BeginLoadAllAvailableBenchmarks(string connectionString)
		{
			return BeginLoadAllAvailableBenchmarks(connectionString,null);
		}

		/// <summary>
		/// Begins the load all available benchmarks with a call back function.
		/// </summary>
		/// <param name="connectionString">Connection string.</param>
		/// <param name="callBack">Call back.</param>
		/// <returns></returns>
		public static IAsyncResult BeginLoadAllAvailableBenchmarks(string connectionString,AsyncCallback callBack)
		{
			LoadAllBenchMarksDelegate benchMarksDelegate=new LoadAllBenchMarksDelegate(LoadAllAvailableBenchmarks);
			return 	benchMarksDelegate.BeginInvoke(connectionString,callBack,benchMarksDelegate);
		}

		/// <summary>
		/// Ends the load all available benchmarks.
		/// </summary>
		/// <param name="asyncResult">An Async Result.</param>
		/// <returns></returns>
		public static AssetMovementConstituentCollection EndLoadAllAvailableBenchmarks(IAsyncResult asyncResult)
		{
			LoadAllBenchMarksDelegate benchMarksDelegate=(LoadAllBenchMarksDelegate) asyncResult.AsyncState;
			return benchMarksDelegate.EndInvoke(asyncResult);
		}
	}
}