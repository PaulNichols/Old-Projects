using System;
using System.Collections;
using System.Collections.Specialized;
using System.Drawing;
using System.Windows.Forms;
using HBOS.FS.AMP.UPD.Controllers;
using HBOS.FS.AMP.UPD.Types.AssetFunds;
using HBOS.FS.AMP.UPD.Types.BenchMark;
using HBOS.FS.AMP.UPD.Types.FundGroups;
using HBOS.FS.AMP.UPD.Types.Funds;
using HBOS.FS.AMP.UPD.Types.StockMarketIndex;
using HBOS.FS.AMP.UPD.WinUI.Helpers;
using HBOS.FS.AMP.UPD.WinUI.UserControls;
using HBOS.FS.AMP.Windows.Controls;
using HBOS.FS.Support.Tex;
using HBOSGrid = HBOS.FS.AMP.Windows.Controls.DataGrid;

namespace HBOS.FS.AMP.UPD.WinUI.Classes
{
	/// <summary>
	/// View Controller for the second level authorisation process
	/// </summary>
	public class SecondLevelAuthorisationViewController : UpdateableStatusViewController
	{
		#region Member variables

		//private bool m_eventsAreSystemGenerated = false;

		#endregion

		#region Action text constants

		private const string selectAllActionText = "Select &All";
		private const string deselectAllActionText = "&Deselect All";
		private const string saveActionText = "&Save";
		private const string cancelActionText = "&Cancel";
		private const string printActionText = "&Print";
		private const string exportActionText = "&Export";

		#endregion

		/// <summary>
		/// Creates a new <see cref="SecondLevelAuthorisationViewController"/> instance.
		/// </summary>
		public SecondLevelAuthorisationViewController(UpdateableStatusView updateView, StatusDataManager dataManager) :
			base(updateView, dataManager)
		{
			T.E();
			updateableView.SaveExecuted += new EventHandler(saveExecuted);
			T.X();
		}

		#region Overrides

		/// <summary>
		/// Creates the actions.
		/// </summary>
		protected override StatusAction[] createActions()
		{
			T.E();

			StatusAction[] result = new StatusAction[7];

			result[0] = new StatusAction();
			result[0].Text = "&Refresh";
			result[0].Executed += new EventHandler(refreshExecuted);

			result[1] = new StatusAction();
			result[1].Text = selectAllActionText;
			result[1].Executed += new EventHandler(selectAllExecuted);
			result[1].RequestVisibility += new RequestVisibilityHandler(visibilityRequested);

			result[2] = new StatusAction();
			result[2].Text = deselectAllActionText;
			result[2].Executed += new EventHandler(deselectAllExecuted);

			result[3] = new StatusAction();
			result[3].Text = saveActionText;
			result[3].Executed += new EventHandler(saveExecuted);

			result[4] = new StatusAction();
			result[4].Text = cancelActionText;
			result[4].Executed += new EventHandler(cancelExecuted);

			result[5] = new StatusAction();
			result[5].Text = printActionText;
			result[5].Executed += new EventHandler(printExecuted);

			result[6] = new StatusAction();
			result[6].Text = exportActionText;
			result[6].Executed += new EventHandler(exportExecuted);


			T.X();
			return result;
		}

		/// <summary>
		/// Configures the grid.
		/// </summary>
		protected override void configureGrid()
		{
			T.E();
			HBOSGrid grid = updateableView.grid;
			DataGridTableStyle style = new DataGridTableStyle();

			DataGridBool1ClickColumn authoriseImportedCheckBox;
			DataGridBool1ClickColumn authorisePredictedCheckBox;

			grid.TableStyles.Clear();
			grid.TableStyles.Add(style);

			style.AlternatingBackColor = Color.WhiteSmoke;
			style.DataGrid = grid;
			style.HeaderForeColor = SystemColors.ControlText;
			style.MappingName = "";

			// Hack to allow for multi-line header rows.
			// This requires a large font (36pt) to be set for grid.HeaderFont through the properties window
			style.HeaderFont = grid.Font;

			const int defaultColWidth = 80;

			//fund columns
			AddTextBoxReadOnlyColumnStyle("FullName", "Fund Name", 300, HorizontalAlignment.Left, "FullName");
			AddTextBoxReadOnlyColumnStyle("PriceDisplay", "Imported.\nFund Price.", defaultColWidth, HorizontalAlignment.Right, "FullName");
			AddTextBoxReadOnlyColumnStyle("PriceMovementPercentDisplay", "Imported.\nFund Price.\nMovement.", defaultColWidth, HorizontalAlignment.Right, "FullName");

			authoriseImportedCheckBox =
				AddBooleanColumnStyle("ProgressStatus", "Authorise\nImported\nFund Price?", defaultColWidth, HorizontalAlignment.Center);

			AddTextBoxReadOnlyColumnStyle("PredictedPriceDisplay", "Predicted.\nFund Price.", defaultColWidth, HorizontalAlignment.Right, "FullName");
			AddTextBoxReadOnlyColumnStyle("PredictedPriceMovementPercentDisplay", "Predicted.\nFund Price.\nMovement.", defaultColWidth, HorizontalAlignment.Right, "FullName");

			authorisePredictedCheckBox =
				AddBooleanColumnStyle("UsePredictedPrice", "Authorise\nPredicted\nFund Price?", defaultColWidth, HorizontalAlignment.Center);

			AddTextBoxReadOnlyColumnStyle("PriceMovementVarianceDisplay", "Fund Price.\nVariance.", defaultColWidth, HorizontalAlignment.Right, "FullName");
			AddTextBoxReadOnlyColumnStyle("PriceMovementRoundedToleranceDisplay", "Within Fund\nPrice Tolerance", 120, HorizontalAlignment.Left, "FullName");

			//asset fund columns
			AddTextBoxReadOnlyColumnStyle("AssetUnitPriceDisplay", "Imported Asset.\nFund Price.", 100, HorizontalAlignment.Right, "FullName");
			AddTextBoxReadOnlyColumnStyle("AssetMovementDisplay", "Imported.\nAsset Fund.\nMovement.", 100, HorizontalAlignment.Right, "FullName");
			AddTextBoxReadOnlyColumnStyle("PredictedAssetMovementDisplay", "Predicted.\nAsset Fund.\nMovement.", 100, HorizontalAlignment.Right, "FullName");
			AddTextBoxReadOnlyColumnStyle("AssetMovementVarianceDisplay", "Asset Fund.\nVariance.", 100, HorizontalAlignment.Right, "FullName");
			AddTextBoxReadOnlyColumnStyle("AssetMovementToleranceDisplay", "Within\nAsset Fund\nTolerance", 100, HorizontalAlignment.Center, "FullName");
			AddTextBoxReadOnlyColumnStyle("FundStatusDisplay", "Price\nStatus ", defaultColWidth, HorizontalAlignment.Left, "FullName");
			AddTextBoxReadOnlyColumnStyle("StatusChangedTime", "Status\nChanged\nTime", 130, HorizontalAlignment.Left, "FullName");

			//assign events to check box columns
			authorisePredictedCheckBox.CheckedChanged += new DataGridBool1ClickColumn.CheckedChangedDelegate(authPredictedPrice_CheckedChanged);
			authoriseImportedCheckBox.CheckedChanged += new DataGridBool1ClickColumn.CheckedChangedDelegate(authImportedPrice_CheckedChanged);


			authorisePredictedCheckBox.AllowNull = false;
			authoriseImportedCheckBox.AllowNull = false;

			T.X();
		}

		#endregion Overrides	

		
		/// <summary>
		/// This structure can be used to get Error messages based on the availability of a benchmark
		/// The idea is that various screens may want to show different messages depending on the context
		/// therefore this logic is in the UI not the IBenchMark implementations
		/// </summary>
		public struct BenchMarkAvalibilityInformation
		{
			private StringDictionary m_ErrorMessages;
			private StringDictionary m_WarningMessages;


			/// <summary>
			/// Creates a new <see cref="BenchMarkAvalibilityInformation"/> instance.
			/// </summary>
			/// <param name="benchmark">Benchmark.</param>
			public BenchMarkAvalibilityInformation(IBenchMark benchmark)
			{
				m_ErrorMessages = new StringDictionary();
				m_WarningMessages = new StringDictionary();

				buildAvailibilityMessageStrings(benchmark);
			}

			/// <summary>
			/// Creates a new <see cref="BenchMarkAvalibilityInformation"/> instance.
			/// </summary>
			/// <param name="fund">Fund.</param>
			public BenchMarkAvalibilityInformation(Fund fund)
			{
				m_ErrorMessages = new StringDictionary();
				m_WarningMessages = new StringDictionary();

				if (fund != null && fund.ParentAssetFund != null && fund.ParentAssetFund.AssetMovementConstituents != null)
				{
					foreach (AssetMovementConstituent movementConstituent in fund.ParentAssetFund.AssetMovementConstituents)
					{
						buildAvailibilityMessageStrings(movementConstituent.BenchMark);
					}
				}
			}

			
			private void buildAvailibilityMessageStrings(IBenchMark benchMark)
			{

				string availabilityMessage = "";
				switch (benchMark.Availability)
				{
					case BenchMarkAvailabilityState.AvailableWithWarnings:

						if (benchMark.Currency.CurrentRate== 0m || benchMark.Currency.PreviousRate == 0m)
						{
							availabilityMessage = "No previous or currenct Import value.";
							addWarning(availabilityMessage);
						}
			
						availabilityMessage="";

						StockMarketIndex stockMarketIndex=benchMark as StockMarketIndex;
						if (stockMarketIndex!=null)
						{
							if (stockMarketIndex.CurrentValue == 0m && stockMarketIndex.PreviousValue == 0m )
							{
								availabilityMessage = "No previous or currenct Import value.";
							}
							else if (stockMarketIndex.PreviousValue == 0m )
							{
								availabilityMessage = "No previous Import value.";
							}
							else if (stockMarketIndex.CurrentValue == 0m)
							{
								availabilityMessage = "No current Import value.";
							}
							addWarning(availabilityMessage);
						}
						break;
					case BenchMarkAvailabilityState.Available:
						break;
					case BenchMarkAvailabilityState.Unavailable:
						Fund fund =benchMark as Fund;
						if(fund!=null)
						{
							if (! fund.IsBenchMarkable )
							{
								availabilityMessage = "The Fund cannot be used as a Benchmark.";
							}
							else
							{
								availabilityMessage = "The Fund is not yet Released.";//currently ", Enum.GetName(typeof (FundStatusType), this.FundStatus), ". It needs to be
							}
							addWarning(availabilityMessage);
						}
						break;
				}
			}

			private void addWarning(string availabilityMessage)
			{
				if(availabilityMessage!=null && availabilityMessage!="" && !m_WarningMessages.ContainsKey(availabilityMessage))
				{
					m_WarningMessages.Add(availabilityMessage,availabilityMessage);
				}
			}

			internal bool AllAvailable
			{
				get { return UniqueErrorMessages.Count == 0 && UniqueWarningMessages.Count == 0; }
			}

			private IList UniqueWarningMessages
			{
				get { return ArrayList.ReadOnly(new ArrayList(m_WarningMessages.Values)); }
			}

			/// <summary>
			/// Gets the unique messages, both error and warning.
			/// </summary>
			/// <value></value>
			public IList UniqueMessages
			{
				get
				{
					ArrayList messagesArray=new ArrayList(m_WarningMessages.Values);
					messagesArray.AddRange(m_ErrorMessages.Values);
					return ArrayList.ReadOnly(messagesArray);
				}
			}

			/// <summary>
			/// Gets the unique error messages.
			/// </summary>
			/// <value></value>
			private IList UniqueErrorMessages
			{
				get { return ArrayList.ReadOnly(new ArrayList(m_ErrorMessages.Values)); }
			}

			/// <summary>
			/// Shows the a message box with either errors or warnings and returns result 
			/// dependning on the messagebox button clicked .
			/// </summary>
			/// <returns></returns>
			public bool ShowMessageBoxAndReturnResult()
			{
				bool result=false;
				if (! this.AllAvailable)
				{
					if (hasErrors())
					{
						String messageString="One or more of the Benchmarks were Unavailable because:\n"+getErrorString();
                        MessageBox.Show( messageString,"Cannot Authorise",MessageBoxButtons.OK,MessageBoxIcon.Error);
						//MessageBoxHelper.Show("UnavailableBenchmarksBody", "CannotAuthoriseTitle", MessageBoxButtons.OK, MessageBoxIcon.Warning);
						result=false;
					}
					else if(hasWarnings())
					{
						String messageString="The following warning(s) have been raised by one or more of this funds benchmarks:\n"+getWarningString()+"Would you like to continue?";
						result= MessageBox.Show( messageString,"Authorisation warnings",MessageBoxButtons.YesNo,MessageBoxIcon.Warning)==DialogResult.Yes;
					}
				}
				else
				{
					result=true;
				}
				return result;
			}

			private string getWarningString()
			{
				String returnString="";
				foreach (string message in this.UniqueWarningMessages)
				{
					returnString+=message+"\n";
				}
				return returnString;
			}

			private string getErrorString()
			{
				String returnString="";
				foreach (string message in this.UniqueErrorMessages)
				{
					returnString+=message+"\n";
				}
				return returnString;
			}

			private bool hasWarnings()
			{
				return this.UniqueWarningMessages.Count>0;
			}

			private bool hasErrors()
			{
				return UniqueErrorMessages.Count>0;
			}

			/// <summary>
			/// Gets the unique messages string which is the contents of the UniqueMessages collection concatinated together.
			/// </summary>
			/// <value></value>
			public string UniqueMessagesString
			{
				get
				{
					return getErrorString()+getWarningString();
				}
			}
		}

		/// <summary>
		/// Checks the benchmarks avalibility.
		/// </summary>
		/// <param name="benchmark">Benchmark.</param>
		/// <returns></returns>
		public BenchMarkAvalibilityInformation CheckBenchMarkAvalibility(IBenchMark benchmark)
		{
			T.E();

			BenchMarkAvalibilityInformation result;
			result = new BenchMarkAvalibilityInformation(benchmark);

			T.X();
			return result;
		}

		

		#region Privates

		/// <summary>
		/// Checks the bench mark avalibility.
		/// </summary>
		/// <param name="fund">Fund.</param>
		/// <returns></returns>
		private BenchMarkAvalibilityInformation checkBenchMarkAvalibility(Fund fund)
		{
			T.E();

			BenchMarkAvalibilityInformation result;
			result = new BenchMarkAvalibilityInformation(fund);

			T.X();
			return result;
		}

		private void doSave()
		{
			// Retrieve only the edited rows.
			FundCollection funds = (FundCollection) FundDecorator.FromDecoratedList( updateableView.grid.RetrieveUpdatedCustomCollection());

			foreach (Fund fund in funds)
			{
				if (fund.FundStatus < Fund.FundStatusType.SecondLevelAuthorised)
				{
					fund.IsDirty = (fund.ProgressStatus || fund.UsePredictedPrice);
				}
				else
				{
					fund.IsDirty = !(fund.ProgressStatus || fund.UsePredictedPrice);
				}
			}

			// Save the valid data.
			if (funds != null && funds.Count > 0)
			{
				try
				{
					FundController controller = new FundController(GlobalRegistry.ConnectionString);
					controller.ProgressFunds(funds, Fund.FundStatusType.SecondLevelAuthorised);
				}
				catch (Exception ex)
				{
					GUIExceptionHelper.LogAndDisplayException("CannotSaveAuthorisationsBody", "CannotSaveAuthorisationsTitle", ex);
				}
			}

			this.refreshData();
//			FundCollection allFunds = (FundCollection)updateableView.grid.RetrieveEntireCustomCollection();
//			foreach(Fund fund in allFunds)
//			{
//				fund.IsDirty = false;
//				foreach(Fund updatedFund in funds)
//				{
//					if (updatedFund.HiPortfolioCode==fund.HiPortfolioCode)
//					{
//						fund.FundStatus=updatedFund.FundStatus;
//						fund.StatusChangedTime=updatedFund.StatusChangedTime;
//						break;
//					}
//				}
//			}
//			updateableView.Data = allFunds;
			//updateableView.Changed = false;
		}

		#endregion

		#region Event Handlers

		private void visibilityRequested(object sender, RequestVisibilityArgs e)
		{
			//defaults
			e.IsEnabled = true;
			e.IsVisible = true;

			if (((StatusAction) sender).Text == selectAllActionText)
			{
				FundGroup selectedFundGroup = ((FundStatusDataManager) dataManager).RetrieveFundGroup();
				if (selectedFundGroup != null)
				{
					e.IsEnabled = selectedFundGroup.AllowSelectAllAuthorisation;
				}
			}
		}

		private void selectAllExecuted(object sender, EventArgs e)
		{
			T.E();

			try
			{
				//m_eventsAreSystemGenerated = true;
				if (view.Data != null && updateableView.Data.Count > 0)
				{
					FundCollection funds = (FundCollection) updateableView.grid.RetrieveEntireCustomCollection();

					bool atLeastOneFailed = false;
					for (int i = 0; i < funds.Count; i++)
					{
						Fund fund = funds[i];

						if (fund.FundStatus < Fund.FundStatusType.SecondLevelAuthorised)
						{
							if (fund.PriceSet && this.checkBenchMarkAvalibility(fund).AllAvailable)
							{
								if (fund.UsePredictedPrice)
								{
									updateableView.grid.SetValue(i, "UsePredictedPrice", false); //causes rowstate to change
									fund.UsePredictedPrice = false;
								}

								if (!fund.ProgressStatus)
								{
									updateableView.grid.SetValue(i, "ProgressStatus", true); //causes rowstate to change
									fund.ProgressStatus = true;
								}

								//updateableView.grid.
							}
							else
							{
								atLeastOneFailed = true;
							}
						}
					}
					updateableView.grid.Refresh();

					if (atLeastOneFailed)
					{
						MessageBoxHelper.Show("UnableToSelectAllForAuthBody", "UnableToSelectAllTitle", MessageBoxButtons.OK, MessageBoxIcon.Information);
					}
				}
			}
			finally
			{
				//m_eventsAreSystemGenerated = false;
				T.X();
			}

		}

		private void deselectAllExecuted(object sender, EventArgs e)
		{
			T.E();
			if (view.Data != null && updateableView.Data.Count > 0)
			{
				FundCollection funds = (FundCollection) updateableView.grid.RetrieveEntireCustomCollection();
				bool anyReleasedFunds = false;

				for (int i = 0; i < funds.Count; i++)
				{
					Fund fund = funds[i];
					if (fund.ProgressStatus || fund.UsePredictedPrice)
					{
						if (fund.FundStatus >= Fund.FundStatusType.Released)
						{
							anyReleasedFunds = true;
						}
						else
						{
							updateableView.grid.SetValue(i, "ProgressStatus", false); //causes rowstate to change
							fund.ProgressStatus = false;

							updateableView.grid.SetValue(i, "UsePredictedPrice", false); //causes rowstate to change
							fund.UsePredictedPrice = false;
						}
					}
				}

				if (anyReleasedFunds)
				{
					MessageBoxHelper.Show("UnauthoriseAllSomeReleasedBody", "UnauthoriseAllSomeReleasedTitle", MessageBoxButtons.OK, MessageBoxIcon.Information);
				}
			}
			else
			{
				MessageBoxHelper.Show("NothingToUnauthoriseBody", "NothingToUnauthoriseTitle", MessageBoxButtons.OK, MessageBoxIcon.Warning);
			}

			T.X();
		}

		private void saveExecuted(object sender, EventArgs e)
		{
			doSave();
		}

		private void cancelExecuted(object sender, EventArgs e)
		{
			loadDataToGrid();
		}

		private void refreshExecuted(object sender, EventArgs e)
		{
			refreshData();
		}

		private void printExecuted(object sender, EventArgs e)
		{
			printGrid("Second Level Authorisation");
		}

		private void exportExecuted(object sender, EventArgs e)
		{
			exportGrid("FundAuthorisation.csv", "HBOS.FS.AMP.UPD.WinUI.UserControls.SecondLevelAuthorisation.xslt");
		}

		private void authPredictedPrice_CheckedChanged(object sender, CheckBoxEventArgs e)
		{
			Fund changedFund =((FundDecorator) fundAtRow(e.RowNumber)).Fund;

			if (e.NewValue == true)
			{
				decimal predPrice = changedFund.PredictedPrice;
				if (predPrice <= 0)
				{
					updateableView.grid.RejectChanges(e.RowNumber);
					MessageBoxHelper.Show("CannotAuthoriseUnpredictedBody", "CannotAuthoriseUnpredictedTitle", MessageBoxButtons.OK, MessageBoxIcon.Warning);
				}
				else
				{
					BenchMarkAvalibilityInformation availibilityInformation=this.checkBenchMarkAvalibility(changedFund);
					bool authorisePredictedPrice=availibilityInformation.AllAvailable;

					if (!authorisePredictedPrice)
					{
						authorisePredictedPrice=availibilityInformation.ShowMessageBoxAndReturnResult();
					}

					if (authorisePredictedPrice)
					{
						if (changedFund.ProgressStatus)
						{
							updateableView.grid.SetValue(e.RowNumber, "ProgressStatus", false);
							updateableView.grid.Refresh();
						}
						updateableView.Changed = true;
					}
					else
					{
						updateableView.grid.RejectChanges(e.RowNumber);
					}
				}
			}
			else
			{
				if (changedFund.FundStatus >= Fund.FundStatusType.Released)
				{
					updateableView.grid.RejectChanges(e.RowNumber);
					MessageBoxHelper.Show("CannotUnauthoriseReleasedBody", "CannotUnauthoriseReleasedTitle", MessageBoxButtons.OK, MessageBoxIcon.Warning);
				}
				else
				{
					updateableView.Changed = true;
				}
			}
		}

		private void authImportedPrice_CheckedChanged(object sender, CheckBoxEventArgs e)
		{
			Fund changedFund = ((FundDecorator )fundAtRow(e.RowNumber)).Fund;

			if (e.NewValue == true)
			{
				if (!changedFund.PriceSet)
				{
					updateableView.grid.RejectChanges(e.RowNumber);
					MessageBoxHelper.Show("CannotAuthoriseUnimportedBody", "CannotAuthoriseUnimportedTitle", MessageBoxButtons.OK, MessageBoxIcon.Warning);
				}
				else
				{
					BenchMarkAvalibilityInformation availibilityInformation= this.checkBenchMarkAvalibility(changedFund);
					bool authoriseImportedPrice=availibilityInformation.AllAvailable;

					if (!authoriseImportedPrice)
					{
						authoriseImportedPrice=availibilityInformation.ShowMessageBoxAndReturnResult();
					}
					if (authoriseImportedPrice)
					{
						if (changedFund.UsePredictedPrice)
						{
							updateableView.grid.SetValue(e.RowNumber, "UsePredictedPrice", false);
							changedFund.UsePredictedPrice=false;
						}

						if (!changedFund.ProgressStatus)
						{
							updateableView.grid.SetValue(e.RowNumber, "ProgressStatus", true); //causes rowstate to change
							changedFund.ProgressStatus = true;
						}
						updateableView.grid.Refresh();

						updateableView.Changed = true;
					}
					else
					{
						updateableView.grid.RejectChanges(e.RowNumber);
					}
				}
			}
			else
			{
				if (changedFund.FundStatus >= Fund.FundStatusType.Released)
				{
					updateableView.grid.RejectChanges(e.RowNumber);
					MessageBoxHelper.Show("CannotUnauthoriseReleasedBody", "CannotUnauthoriseReleasedTitle", MessageBoxButtons.OK, MessageBoxIcon.Warning);
				}
				else
				{
					updateableView.Changed = true;
				}
			}
		}

		#endregion
	}
}